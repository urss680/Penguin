<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LibrillaiA</title>
    <!-- Favicon para la pestaña del navegador -->
    <link rel="icon" href="https://fonts.gstatic.com/s/e/notoemoji/latest/1f301/512.gif" type="image/gif">
    <!-- Importación de JSZip para la descarga de archivos ZIP -->
    <script src="https://unpkg.com/jszip@3.10.1/dist/jszip.min.js"></script>
    <!-- Font Awesome para iconos -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        #chat-container {
            width: 90%;
            max-width: 800px;
            margin: 20px auto 10px auto;
            border: 1px solid #ddd;
            background-color: white;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            height: 500px;
            overflow-y: auto;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            border-radius: 8px;
        }

        .user-message,
        .gemini-message {
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 8px;
            word-wrap: break-word;
            max-width: 80%;
        }

        .user-message {
            background-color: #e3f2fd;
            text-align: right;
            align-self: flex-end;
            color: #1a73e8;
            /* A shade of blue */
        }

        .gemini-message {
            background-color: #f0f0f0;
            text-align: left;
            color: #333;
            align-self: flex-start;
        }

        #input-container {
            width: 90%;
            max-width: 800px;
            margin: 10px auto;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            /* Allow items to wrap */
        }

        #message-input {
            flex-grow: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            min-width: 150px;
            /* Ensure input doesn't get too small */
        }

        #send-button,
        #read-button,
        #download-pdf-button,
        #archivos-button,
        #report-button,
        #html-mode-button,
        #image-mode-button,
        #schema-mode-button,
        #deep-report-button {
            /* Added new button to style */
            padding: 10px 15px;
            background-color: #4caf50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            white-space: nowrap;
            /* Prevent button text from wrapping */
        }

        #send-button:hover,
        #read-button:hover,
        #download-pdf-button:hover,
        #archivos-button:hover,
        #report-button:hover,
        #html-mode-button:hover,
        #image-mode-button:hover,
        #schema-mode-button:hover,
        #deep-report-button:hover {
            /* Added new button to style */
            background-color: #45a049;
        }

        #file-input {
            display: none;
        }

        label[for="file-input"] {
            background-color: #007bff;
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            white-space: nowrap;
        }

        label[for="file-input"]:hover {
            background-color: #0056b3;
        }
        
        /* Moved font-size and font-family input styling here */
        #font-size { 
            width: 100%;
            padding: 8px;
            margin-bottom: 0px; /* Adjusted margin */
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
        }


        code {
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
            white-space: pre-wrap;
            display: block;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        /* Styles for tables */
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 10px 0;
            border: 1px solid #ddd;
        }

        th, td {
            text-align: left;
            padding: 8px;
            border-bottom: 1px solid #ddd;
        }

        tr:nth-child(even) {
            background-color: #f2f2f2;
        }

        th {
            background-color: #4CAF50;
            color: white;
        }

        /* Styles for the side file menu */
        #archivo-menu {
            position: fixed;
            top: 0;
            right: -300px;
            width: 300px;
            height: 100%;
            background-color: #f8f8f8;
            border-left: 1px solid #ccc;
            transition: right 0.5s;
            padding: 20px;
            box-sizing: border-box;
            z-index: 1000;
            box-shadow: -2px 0 5px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
            /* Enable scrolling for content */
        }

        #archivo-menu.active {
            right: 0;
        }

        #archivo-menu h2 {
            margin-top: 0;
            color: #333;
        }

        #close-menu-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 1.8em;
            cursor: pointer;
            color: #555;
        }

        #close-menu-button:hover {
            color: #000;
        }

        .tab-buttons {
            display: flex;
            margin-bottom: 15px;
            border-bottom: 1px solid #ddd;
            flex-wrap: wrap; /* Allow tab buttons to wrap */
        }

        .tab-buttons button {
            flex: 1;
            padding: 10px 5px; /* Reduced padding for more buttons */
            border: none;
            background-color: #e0e0e0;
            cursor: pointer;
            font-size: 0.8em; /* Reduced font size */
            transition: background-color 0.3s;
            border-radius: 5px 5px 0 0;
            margin-right: 2px;
            margin-bottom: 5px; /* Add margin for wrapped buttons */
            white-space: nowrap; /* Prevent text wrapping inside button */
        }

        .tab-buttons button:last-child {
            margin-right: 0;
        }

        .tab-buttons button.active-tab {
            background-color: #007bff;
            color: white;
            font-weight: bold;
        }

        .tab-buttons button:hover:not(.active-tab) {
            background-color: #d0d0d0;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active-tab-content {
            display: block;
        }

        #archivo-subir {
            border: 2px dashed #aaa;
            padding: 20px;
            text-align: center;
            margin-bottom: 15px;
            cursor: pointer;
            background-color: #f0f0f0;
            border-radius: 8px;
            transition: background-color 0.3s;
        }

        #archivo-subir:hover {
            background-color: #e9e9e9;
        }

        /* Styles for the paste textarea */
        #binary-paste-textarea {
            width: 100%;
            min-height: 80px;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 8px;
            box-sizing: border-box;
            margin-top: 10px;
            resize: vertical;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #html-preview-textarea,
        #url-context-code-python,
        #url-context-code-js {
            width: 100%;
            min-height: 150px;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 8px;
            box-sizing: border-box;
            margin-top: 10px;
            resize: vertical;
            font-family: 'Courier New', monospace;
        }
        
        /* Modificado: Data URL display con scroll horizontal */
        #html-data-url-display { 
            width: 100%;
            min-height: 50px;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 8px;
            box-sizing: border-box;
            margin-bottom: 10px;
            background-color: #e9e9e9;
            font-size: 0.8em;
            white-space: nowrap; /* Prevent wrapping */
            overflow-x: auto; /* Enable horizontal scroll */
            word-break: break-all; /* Allow breaking long words within the span */
            display: flex; /* Use flex to allow content to overflow horizontally */
            align-items: center;
        }
        #html-data-url-display span {
            flex-shrink: 0; /* Prevent the text from shrinking */
        }


        #open-html-new-tab-button,
        #open-data-url-button,
        #copy-data-url-button, /* READDED: Copy Data URL button */
        #download-html-button {
            padding: 10px 15px;
            background-color: #4caf50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            white-space: nowrap;
        }

        #open-html-new-tab-button:hover,
        #open-data-url-button:hover,
        #copy-data-url-button:hover, /* READDED: Hover for Copy Data URL */
        #download-html-button:hover {
            background-color: #45a049;
        }

        #open-data-url-button {
            background-color: #17a2b8; /* Cian for open data url */
        }
        #open-data-url-button:hover {
            background-color: #138496;
        }

        #copy-data-url-button { /* READDED: Style for Copy Data URL */
            background-color: #6c757d; /* Gray */
        }
        #copy-data-url-button:hover {
            background-color: #5a6268;
        }

        #archivos-lista,
        /* #documents-lista removed */
        #url-list,
        #retrieved-url-list { /* NEW: for URL retrieval status */
            list-style-type: none;
            padding: 0;
        }

        #archivos-lista li,
        /* #documents-lista li removed */
        #url-list li,
        #retrieved-url-list li { /* NEW: for URL retrieval status */
            border-bottom: 1px solid #eee;
            padding: 8px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9em;
        }

        .url-retrieval-status-success {
            color: green;
        }
        .url-retrieval-status-failure {
            color: red;
        }
        .url-retrieval-status-unspecified {
            color: orange;
        }


        .archivo-iconos {
            display: flex;
            gap: 10px;
        }

        .archivo-iconos a {
            cursor: pointer;
            text-decoration: none;
            color: #555;
            font-size: 1.2em;
            transition: color 0.3s;
        }

        .archivo-iconos a:hover {
            color: #007bff;
        }
        
        .url-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
        }

        .url-item a {
            flex-grow: 1;
            margin-right: 10px;
            word-break: break-all;
            color: #007bff;
            text-decoration: none;
        }

        .url-item a:hover {
            text-decoration: underline;
        }

        .delete-url-button {
            background-color: #dc3545;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 8px;
            cursor: pointer;
            font-size: 0.8em;
            transition: background-color 0.2s;
        }

        .delete-url-button:hover {
            background-color: #c82333;
        }

        /* Container for the bottom buttons */
        #bottom-buttons-container {
            width: 90%;
            max-width: 800px;
            margin: 10px auto 20px auto;
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        #html-preview-iframe {
            width: 100%;
            height: 200px;
            border: 1px solid #ccc;
            margin-top: 10px;
            background-color: white;
            border-radius: 5px;
        }

        /* Fullscreen HTML Preview Modal Styles */
        #fullscreen-html-modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        #fullscreen-html-modal.active {
            display: flex;
        }

        #fullscreen-html-modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 20px;
            border: 1px solid #888;
            width: 90%;
            height: 90%;
            display: flex;
            flex-direction: column;
            position: relative;
            border-radius: 8px;
        }

        #fullscreen-html-iframe {
            width: 100%;
            height: calc(100% - 40px);
            border: none;
            background-color: white;
        }

        #close-fullscreen-modal-button {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            background: none;
            border: none;
            padding: 0;
        }

        #close-fullscreen-modal-button:hover,
        #close-fullscreen-modal-button:focus {
            color: #000;
            text-decoration: none;
            cursor: pointer;
        }

        /* New styles for web search section */
        #web-searches-content {
            padding: 10px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background-color: #f9f9f9;
            margin-top: 10px;
        }

        #web-searches-content h3 {
            margin-top: 0;
            color: #555;
        }

        #web-searches-content ul {
            list-style-type: none;
            padding: 0;
        }

        #web-searches-content li {
            margin-bottom: 5px;
        }

        #web-searches-content a {
            color: #007bff;
            text-decoration: none;
        }

        #web-searches-content a:hover {
            text-decoration: underline;
        }

        .google-search-suggestions-container {
            margin-top: 15px;
            padding: 10px;
            border: 1px solid #cceeff;
            background-color: #e6f7ff;
            border-radius: 8px;
        }

        /* Styles for the Report button */
        #report-button {
            background-color: white;
            /* Default inactive */
            color: #ffc107;
            /* Yellow text */
            border: 1px solid #ffc107;
            /* Yellow border */
        }

        #report-button.report-active {
            background-color: #ffc107;
            /* Yellow background */
            color: white;
            /* White text */
        }

        #report-button:hover {
            opacity: 0.8;
            /* Slight hover effect */
        }

        /* Styles for the HTML Mode button (now for HTML filtering) */
        #html-mode-button {
            background-color: white;
            /* Default inactive */
            color: #6f42c1;
            /* Purple text (like old AI Mode) */
            border: 1px solid #6f42c1;
            /* Purple border */
        }

        #html-mode-button.html-active {
            background-color: #6f42c1;
            /* Purple background */
            color: white;
            /* White text */
        }

        #html-mode-button:hover {
            opacity: 0.8;
            /* Slight hover effect */
        }

        /* Styles for the Image Mode button */
        #image-mode-button {
            background-color: white;
            /* Default inactive */
            color: #fd7e14;
            /* Orange text */
            border: 1px solid #fd7e14;
            /* Orange border */
        }

        #image-mode-button.image-active {
            background-color: #fd7e14;
            /* Orange background */
            color: white;
            /* White text */
        }

        #image-mode-button:hover {
            opacity: 0.8;
            /* Slight hover effect */
        }

        /* Styles for the Schema Mode button */
        #schema-mode-button {
            background-color: white;
            color: #17a2b8;
            /* Cian */
            border: 1px solid #17a2b8;
        }

        #schema-mode-button.schema-active {
            background-color: #17a2b8;
            color: white;
        }

        #schema-mode-button:hover {
            opacity: 0.8;
        }

        /* Styles for the Deep Report button (now Advanced Report) */
        #deep-report-button {
            background-color: white;
            color: #dc3545;
            /* Red */
            border: 1px solid #dc3545;
        }

        #deep-report-button.advanced-report-active {
            /* New class for active state */
            background-color: #dc3545;
            color: white;
        }

        #deep-report-button:hover {
            opacity: 0.8;
        }


        /* Styles from Imagen 4 HTML */
        /* Contenedor principal de la aplicación de imagen */
        #image-4-container {
            display: none;
            /* Initially hidden */
            width: 100%;
            max-width: 800px;
            /* Adjust as needed for overall layout */
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f2f5;
            overflow-x: hidden;
            padding: 20px;
            box-sizing: border-box;
        }

        #image-4-container .container {
            width: 100%;
            max-width: 600px;
            background-color: #ffffff;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 20px;
        }

        #image-4-container img {
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            /* Bordes más redondeados */
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.08);
            margin-bottom: 20px;
            max-width: 100%;
            height: auto;
            cursor: pointer;
            transition: transform 0.2s ease-in-out;
        }

        #image-4-container img:hover {
            transform: scale(1.02);
        }

        /* ESTILO PARA IMAGEN SELECCIONADA EN LA GALERÍA */
        #image-4-container #galeriaImagenes img.seleccionada {
            border: 4px solid #4299e1 !important;
            /* Azul de Tailwind, y !important para asegurar visibilidad */
            box-shadow: 0 0 0 4px rgba(66, 153, 225, 0.5);
            /* Sombra suave alrededor del borde */
        }

        #image-4-container h1 {
            color: #2d3748;
            /* Color de texto más oscuro */
            margin-bottom: 25px;
            text-align: center;
            font-size: 2.5rem;
            /* Tamaño de fuente más grande */
            font-weight: 700;
        }

        #image-4-container input[type="text"],
        #image-4-container .modelo-selector {
            padding: 12px 15px;
            font-size: 1rem;
            border: 1px solid #cbd5e0;
            /* Borde más suave */
            border-radius: 8px;
            margin-bottom: 15px;
            width: calc(100% - 30px);
            /* Ajuste para padding */
            max-width: 450px;
            box-sizing: border-box;
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }

        #image-4-container input[type="text"]:focus,
        #image-4-container .modelo-selector:focus {
            outline: none;
            border-color: #4299e1;
            box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.5);
        }

        #image-4-container .button-group {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            /* Espacio entre botones */
            margin-top: 10px;
            width: 100%;
        }

        #image-4-container button {
            padding: 12px 24px;
            font-size: 1rem;
            color: white;
            border: none;
            border-radius: 8px;
            /* Bordes más redondeados */
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.1s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            flex-grow: 1;
            /* Permite que los botones crezcan */
            min-width: 150px;
            /* Ancho mínimo para botones */
        }

        #image-4-container button:hover {
            transform: translateY(-2px);
        }

        #image-4-container button:active {
            transform: translateY(0);
        }

        #image-4-container #generarImagen {
            background-color: #4CAF50;
        }

        /* Verde */
        #image-4-container #generarImagen:hover {
            background-color: #45a049;
        }

        #image-4-container #variarImagen {
            background-color: #008CBA;
        }

        /* Azul */
        #image-4-container #variarImagen:hover {
            background-color: #007ba7;
        }

        #image-4-container #variacionAlgoritmica {
            background-color: #800080;
        }

        /* Púrpura */
        #image-4-container #variacionAlgoritmica:hover {
            background-color: #660066;
        }

        #image-4-container #pararVariacion {
            background-color: #f44336;
            display: none;
        }

        /* Rojo, inicialmente oculto */
        #image-4-container #pararVariacion:hover {
            background-color: #d32f2f;
        }

        #image-4-container #verBiblioteca {
            background-color: #28a745;
        }

        /* Verde oscuro */
        #image-4-container #verBiblioteca:hover {
            background-color: #218838;
        }

        #image-4-container #ocultarBiblioteca {
            background-color: #dc3545;
            display: none;
        }

        /* Rojo oscuro, inicialmente oculto */
        #image-4-container #ocultarBiblioteca:hover {
            background-color: #c82333;
        }

        #image-4-container #descargarImagenPrincipal {
            background-color: #17a2b8;
        }

        /* Cian */
        #image-4-container #descargarImagenPrincipal:hover {
            background-color: #138496;
        }

        #image-4-container #descargarGaleria {
            background-color: #ffc107;
            color: #333;
        }

        /* Amarillo, texto oscuro */
        #image-4-container #descargarGaleria:hover {
            background-color: #e0a800;
        }

        #image-4-container #descargarSeleccionadas {
            background-color: #6f42c1;
        }

        /* Índigo */
        #image-4-container #descargarSeleccionadas:hover {
            background-color: #5a2d9c;
        }

        /* New style for "Volver al Chat" button */
        #image-4-container #backToChatButton {
            background-color: #6c757d;
            /* Grey */
        }

        #image-4-container #backToChatButton:hover {
            background-color: #5a6268;
        }

        /* Styles for the "Configuración" button */
        #image-4-container #configurarDimensionesBtn {
            background-color: #6f42c1;
        }

        #image-4-container #configurarDimensionesBtn:hover {
            background-color: #5a2d9c;
        }


        #image-4-container #galeriaImagenes {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 30px;
            gap: 15px;
            /* Espacio entre imágenes de la galería */
            display: none;
            /* Inicialmente oculta la galería */
            width: 100%;
        }

        #image-4-container #galeriaImagenes img {
            width: 180px;
            /* Tamaño más pequeño para miniaturas */
            height: 180px;
            /* Asegura que sean cuadradas */
            object-fit: cover;
            /* Recorta la imagen para que quepa */
            margin: 0;
            /* Eliminado margen extra */
            border: 1px solid #e0e0e0;
            /* Borde predeterminado de la galería */
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            transition: transform 0.2s ease-in-out, border 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }

        #image-4-container #galeriaImagenes img:hover {
            transform: scale(1.05);
        }

        /* Estilos para el mensaje temporal */
        #image-4-container #userMessage {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            text-align: center;
        }

        /* New styles for interactive schema */
        .interactive-schema {
            margin-top: 15px;
            padding: 10px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background-color: #f9f9f9;
        }

        .interactive-schema h2 {
            color: #2d3748;
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
            font-size: 1.8em;
        }

        .schema-section {
            margin-bottom: 5px;
            border: 1px solid #eee;
            border-radius: 5px;
            background-color: #fff;
            overflow: hidden;
            /* Ensures border-radius applies correctly */
        }

        .schema-heading {
            font-weight: bold;
            padding: 8px 10px;
            cursor: pointer;
            background-color: #f0f0f0;
            border-radius: 5px;
            /* Apply to summary */
            transition: background-color 0.2s;
            display: block;
            /* Make summary take full width */
        }

        .schema-heading:hover {
            background-color: #e0e0e0;
        }

        .schema-content {
            padding: 5px 10px 10px 10px;
            margin-top: 0;
            line-height: 1.5;
            color: #555;
        }

        .schema-subsections {
            margin-left: 15px;
            border-left: 1px dashed #ccc;
            padding-left: 10px;
        }

        /* Styles for the Advanced Report Tab */
        #advanced-report-content {
            padding: 10px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background-color: #f9f9f9;
            margin-top: 10px;
        }

        #advanced-report-content h3 {
            margin-top: 0;
            color: #555;
            text-align: center;
            margin-bottom: 15px;
        }

        #report-plan-list {
            list-style: none;
            padding: 0;
            margin-bottom: 20px;
        }

        #report-plan-list li {
            background-color: #e8f5e9;
            /* Light green */
            border: 1px solid #c8e6c9;
            /* Darker green border */
            border-radius: 5px;
            padding: 10px 15px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            font-size: 0.95em;
            cursor: grab;
            /* Indicate draggable */
            transition: background-color 0.2s, box-shadow 0.2s;
        }

        #report-plan-list li.dragging {
            opacity: 0.5;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
        }

        #report-plan-list li.completed {
            background-color: #d4edda;
            /* Even lighter green */
            color: #155724;
            /* Dark green text */
            text-decoration: line-through;
        }

        #report-plan-list li input[type="checkbox"] {
            margin-right: 10px;
            transform: scale(1.2);
            /* Make checkbox slightly larger */
        }

        #report-plan-list li .report-step-text {
            flex-grow: 1;
            /* Allow text to take available space */
            outline: none;
            /* Remove outline on focus for contenteditable */
            padding: 2px 5px;
            /* Add some padding for editing */
            border-radius: 3px;
        }

        #report-plan-list li .report-step-text:hover,
        #report-plan-list li .report-step-text:focus {
            background-color: #f0f0f0;
            /* Highlight on hover/focus */
        }


        #report-progress-container {
            width: 100%;
            background-color: #e0e0e0;
            border-radius: 5px;
            margin-top: 10px;
            overflow: hidden;
            /* Ensures progress bar stays within bounds */
        }

        #report-progress-bar {
            height: 25px;
            width: 0%;
            background-color: #4CAF50;
            border-radius: 5px;
            text-align: center;
            line-height: 25px;
            color: white;
            font-weight: bold;
            transition: width 0.5s ease-in-out;
        }

        #add-step-container {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        #new-step-input {
            flex-grow: 1;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }

        #add-step-button {
            padding: 8px 15px;
            background-color: #6c757d;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        #add-step-button:hover {
            background-color: #5a6268;
        }


        #report-actions-container {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
        }

        #start-report-plan-button,
        #reset-report-plan-button {
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        #start-report-plan-button:hover,
        #reset-report-plan-button:hover {
            background-color: #0056b3;
        }


        /* --- Estilos para el Modal de Configuración (Imagen 4) --- */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            /* Oculto por defecto */
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.25);
            max-width: 450px;
            width: 90%;
            display: flex;
            flex-direction: column;
            gap: 15px;
            position: relative;
            animation: fadeInScale 0.3s ease-out forwards;
        }

        .modal-content h2 {
            color: #2d3748;
            margin-bottom: 10px;
            text-align: center;
            font-size: 1.8rem;
        }

        .modal-content label {
            font-size: 1rem;
            color: #4a5568;
            display: flex;
            flex-direction: column;
        }

        .modal-content input[type="number"] {
            padding: 10px 12px;
            font-size: 1rem;
            border: 1px solid #cbd5e0;
            border-radius: 8px;
            margin-top: 5px;
            width: calc(100% - 24px);
            box-sizing: border-box;
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }

        .modal-content input[type="number"]:focus {
            outline: none;
            border-color: #4299e1;
            box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.5);
        }

        .modal-content .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }

        .modal-content .checkbox-group input[type="checkbox"] {
            transform: scale(1.2); /* Make checkbox slightly larger */
        }

        .modal-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
        }

        .modal-buttons button {
            padding: 10px 20px;
            font-size: 0.95rem;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.1s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08);
            flex-grow: 0;
            /* No crece */
            min-width: unset;
            /* Anula min-width del button global */
        }

        #modalAceptarBtn {
            background-color: #4CAF50;
            color: white;
        }

        #modalAceptarBtn:hover {
            background-color: #45a049;
        }

        #modalCancelarBtn {
            background-color: #cbd5e0;
            color: #333;
        }

        #modalCancelarBtn:hover {
            background-color: #a0aec0;
        }

        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: scale(0.9);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }


        /* Responsive adjustments */
        @media (max-width: 768px) {

            #chat-container,
            #input-container,
            #bottom-buttons-container {
                width: 95%;
                margin-left: auto;
                margin-right: auto;
            }

            #input-container {
                flex-direction: column;
                align-items: stretch;
            }

            #send-button,
            #read-button,
            #download-pdf-button,
            #archivos-button,
            #report-button,
            #html-mode-button,
            #image-mode-button,
            #schema-mode-button,
            /* Added for responsive */
            #deep-report-button,
            /* Added for responsive */
            label[for="file-input"] {
                width: 100%;
                text-align: center;
            }

            #archivo-menu {
                width: 100%;
                right: -100%;
            }

            #archivo-menu.active {
                right: 0;
            }

            /* Image 4 responsive adjustments */
            #image-4-container h1 {
                font-size: 2rem;
            }

            #image-4-container .button-group {
                flex-direction: column;
                gap: 8px;
            }

            #image-4-container button {
                width: 100%;
                min-width: unset;
            }

            #image-4-container input[type="text"],
            #image-4-container .modelo-selector {
                width: calc(100% - 20px);
                /* Ajuste para móviles */
            }

            #image-4-container #galeriaImagenes img {
                width: 150px;
                height: 150px;
            }

            #add-step-container {
                flex-direction: column;
            }

            .modal-content {
                padding: 20px;
            }

            .modal-content input[type="number"] {
                width: calc(100% - 20px);
            }

            .modal-buttons {
                flex-direction: column-reverse;
                gap: 8px;
            }

            .modal-buttons button {
                width: 100%;
            }
        }

        /* NEW: Styles for the thought toggle button and thought content */
        .thought-toggle-button {
            padding: 6px 10px;
            background-color: #8A2BE2; /* Violet */
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.85em;
            transition: background-color 0.3s ease;
            margin-bottom: 5px; /* Space between button and thought content */
        }

        .thought-toggle-button:hover {
            background-color: #6A1BA0; /* Darker violet on hover */
        }

        .model-thought {
            background-color: #f0f8ff; /* Light blue background for thought */
            border-left: 4px solid #8A2BE2; /* Violet border */
            padding: 10px;
            margin-top: 5px;
            border-radius: 0 8px 8px 0; /* Rounded corners only on right side */
            font-size: 0.9em;
            color: #333;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }

        .hidden {
            display: none;
        }
    </style>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.css"
        xintegrity="sha512-vDnqY12kF+30rx1J1/yYkRb1sJmJ/R5h30V0fC6wzK+9J80/32Y6M+j692sY6F6w5kK3e9iXN7zHq8yW4+9Vw=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

</head>

<body>

    <div id="chat-container"></div>

    <div id="input-container">
        <input type="text" id="message-input" placeholder="Escribe tu mensaje...">
        <label for="file-input">Adjuntar Archivos</label>
        <!-- Added webkitdirectory attribute for folder upload -->
        <input type="file" id="file-input" accept="image/*, application/pdf, audio/*, video/*" multiple webkitdirectory mozdirectory>
        <button id="send-button">Enviar</button>
    </div>

    <div id="bottom-buttons-container">
        <button id="read-button"><i class="fas fa-volume-up"></i> Escuchar</button>
        <button id="report-button"><i class="fas fa-file-alt"></i> Informe</button>
        <button id="deep-report-button"><i class="fas fa-book"></i> Informe Profundo</button>
        <button id="html-mode-button"><i class="fas fa-code"></i> Modo HTML</button>
        <button id="image-mode-button"><i class="fas fa-image"></i> Modo Imagen 4</button>
        <button id="schema-mode-button"><i class="fas fa-sitemap"></i> Modo Esquema</button>
        <button id="download-pdf-button">Descargar PDF</button>
        <button id="archivos-button" style="background-color: #007bff;">MAS</button>
        <!-- Font size selector moved to audio tab -->
        <select id="font-size">
            <option value="10">10px</option>
            <option value="12">12px</option>
            <option value="14">14px</option>
            <option value="16" selected>16px</option>
            <option value="18">18px</option>
            <option value="20">20px</option>
            <option value="24">24px</option>
        </select>
    </div>


    <div id="archivo-menu">
        <h2>Fuentes</h2> <!-- Changed from Archivos to Fuentes -->
        <button id="close-menu-button">&times;</button>
        <div class="tab-buttons">
            <button id="tab-button-files" class="active-tab">Fuentes</button> <!-- Changed from Archivos to Fuentes -->
            <button id="tab-button-html-preview">Previsualizar HTML</button>
            <!-- Removed tab-button-documents -->
            <button id="tab-button-web-searches">Búsquedas Web</button>
            <button id="tab-button-advanced-report">Informe Avanzado</button>
            <button id="tab-button-thinking">Pensamiento</button> <!-- MODIFIED: Changed from Creaciones -->
            <!-- Removed tab-button-url-context -->
        </div>

        <div id="tab-content-files" class="tab-content active-tab-content">
            <div id="archivo-subir">
                <p>Arrastra y suelta archivos/carpetas aquí, o haz clic para subir.</p>
                <!-- Added webkitdirectory attribute for folder upload -->
                <input type="file" id="archivo-subir-input" style="display: none;" multiple webkitdirectory mozdirectory>
            </div>
            <p>O pega imágenes o archivos aquí:</p>
            <textarea id="binary-paste-textarea" placeholder="Pega imágenes o archivos del portapapeles..."></textarea>
            <h3>Archivos subidos en esta conversación:</h3>
            <ul id="archivos-lista">
            </ul>

            <!-- NEW URL CONTEXT SECTION - MOVED HERE -->
            <h4>Añadir URL para el Contexto del Chat</h4>
            <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                <input type="text" id="url-input" placeholder="Introduce una URL (ej. https://ejemplo.com)" style="flex-grow: 1; padding: 8px; border: 1px solid #ccc; border-radius: 5px;">
                <button id="add-url-button" style="padding: 8px 15px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">Añadir URL</button>
            </div>
            
            <h4>URL Añadidas:</h4>
            <ul id="url-list">
                <!-- URLs will be dynamically added here -->
            </ul>

            <!-- NEW: URL RETRIEVAL STATUS DISPLAY -->
            <div id="url-retrieval-status-display" style="margin-top: 20px; border-top: 1px solid #eee; padding-top: 15px; display: none;">
                <h4>Estado de Recuperación de URLs de Gemini:</h4>
                <ul id="retrieved-url-list">
                    <!-- Retrieval status will be dynamically added here -->
                </ul>
            </div>
            <!-- END NEW URL RETRIEVAL STATUS DISPLAY -->

        </div>

        <div id="tab-content-html-preview" class="tab-content">
            <p>Data URL del código HTML:</p>
            <!-- Modificado: Data URL display con span para texto y estilo para scroll -->
            <div id="html-data-url-display">
                <span id="data-url-text"></span>
            </div> 
            <button id="copy-data-url-button">Copiar Data URL</button> <!-- READDED: Copy Data URL button -->
            <button id="open-data-url-button" style="display: none;">Abrir Data URL</button>
            <button id="download-html-button">Descargar HTML</button>
            <p>Pega tu código HTML aquí para previsualizarlo:</p>
            <textarea id="html-preview-textarea" placeholder="<!DOCTYPE html><html>...</html>"></textarea>
            <button id="open-html-new-tab-button">Abrir HTML</button>
            <iframe id="html-preview-iframe" sandbox="allow-scripts allow-same-origin"
                style="width:100%; height:200px; border:1px solid #ccc; margin-top:10px;"></iframe>
        </div>

        <!-- Removed tab-content-documents -->

        <div id="tab-content-web-searches" class="tab-content">
            <h3>Resultados de Búsqueda de Google:</h3>
            <div id="google-search-suggestions-container" class="google-search-suggestions-container">
            </div>
            <h3>Fuentes:</h3>
            <ul id="web-search-sources-list">
            </ul>
        </div>

        <div id="tab-content-advanced-report" class="tab-content">
            <div id="advanced-report-content">
                <h3>Plan de Informe Avanzado</h3>
                <ul id="report-plan-list">
                    <!-- Plan steps will be inserted here dynamically -->
                </ul>
                <div id="add-step-container">
                    <input type="text" id="new-step-input" placeholder="Añadir nuevo paso al plan...">
                    <button id="add-step-button">Añadir Paso</button>
                </div>
                <div id="report-progress-container">
                    <div id="report-progress-bar">0%</div>
                </div>
                <div id="report-actions-container">
                    <button id="start-report-plan-button">Comenzar Plan de Informe</button>
                    <button id="reset-report-plan-button">Reiniciar Plan</button>
                </div>
            </div>
        </div>

        <!-- MODIFIED: Content for Thinking Tab -->
        <div id="tab-content-thinking" class="tab-content">
            <!-- Nueva sección para la configuración de pensamiento -->
            <div id="thinking-config-container" class="w-full max-w-2xl bg-white border border-gray-300 rounded-lg shadow-md p-4 flex flex-col space-y-4">
                <h3 class="text-lg font-bold mb-2">Configuración de Pensamiento (conceptual)</h3>

                <div class="flex items-center justify-between">
                    <label for="thinking-mode-toggle" class="font-semibold text-gray-700">Modo de Pensamiento</label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="thinking-mode-toggle" checked>
                        <span class="slider"></span>
                    </label>
                </div>

                <div class="flex items-center justify-between">
                    <label for="set-thinking-budget-toggle" class="font-semibold text-gray-700">Establecer Presupuesto de Pensamiento</label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="set-thinking-budget-toggle" checked>
                        <span class="slider"></span>
                    </label>
                </div>

                <div id="budget-slider-container" class="flex items-center space-x-4">
                    <input type="range" id="thinking-budget-slider" min="0" max="24576" value="24576" class="flex-grow h-2 bg-blue-200 rounded-lg appearance-none cursor-pointer">
                    <span id="thinking-budget-value" class="w-24 p-2 border border-gray-300 rounded-lg text-center font-mono">24576</span>
                </div>
            </div>
        </div>
        <!-- END MODIFIED CONTENT -->

        <!-- Removed tab-content-url-context -->

    </div>

    <div id="fullscreen-html-modal">
        <div id="fullscreen-html-modal-content">
            <button id="close-fullscreen-modal-button">&times;</button>
            <iframe id="fullscreen-html-iframe" sandbox="allow-scripts allow-same-origin"></iframe>
        </div>
    </div>

    <!-- Contenedor principal del modo Imagen 4 -->
    <div id="image-4-container">
        <div class="container">
            <h1>Imagen 4</h1>
            <!-- Imagen principal generada, con un placeholder inicial -->
            <img id="imagenGenerada" src="https://placehold.co/512x512/cccccc/333333?text=Cargando..."
                alt="Imagen Generada">

            <!-- Campo de texto para el mensaje/prompt de la imagen -->
            <input type="text" id="mensajeInputImg4" placeholder="Introduce tu mensaje o descripción">
            <!-- Selector de modelo de generación de imagen (ahora debajo del input de texto) -->
            <select id="modeloSelector" class="modelo-selector">
                <option value="flux">Modelo Normal</option>
                <option value="turbo">Modelo Rápido</option>
            </select>

            <!-- Grupo de botones para acciones -->
            <div class="button-group">
                <button id="generarImagen">Generar Nueva Imagen</button>
                <button id="variarImagen">Variar Imagen</button>
                <button id="variacionAlgoritmica">Variacion Algoritmica</button>
                <button id="pararVariacion" style="display: none;">Parar Variación</button>
                <button id="verBiblioteca">Ver Biblioteca</button>
                <button id="ocultarBiblioteca" style="display: none;">Ocultar Biblioteca</button>
                <button id="descargarImagenPrincipal">Descargar Imagen</button>
                <button id="descargarGaleria">Descargar Galería</button>
                <button id="descargarSeleccionadas">Descargar Seleccionadas</button>
                <button id="configurarDimensionesBtn">Configuración</button>
                <button id="backToChatButton"><i class="fas fa-comments"></i> Volver al Chat</button>
            </div>
        </div>
        <!-- Contenedor para la galería de imágenes generadas -->
        <div id="galeriaImagenes"></div>
        <!-- Mensaje temporal para el usuario (ej. confirmaciones, errores) -->
        <div id="userMessage"></div>
    </div>

    <!-- Modal de Configuración de Dimensiones -->
    <div id="configModal" class="modal-overlay">
        <div class="modal-content">
            <h2>Configurar Dimensiones</h2>
            <label for="modalAnchoInput">Ancho (px):
                <input type="number" id="modalAnchoInput" value="512" min="1" step="1">
            </label>
            <label for="modalAltoInput">Alto (px):
                <input type="number" id="modalAltoInput" value="512" min="1" step="1">
            </label>
            <div class="checkbox-group">
                <input type="checkbox" id="enhanceCheckbox">
                <label for="enhanceCheckbox">Mejorar descripción con IA</label>
            </div>
            <div class="modal-buttons">
                <button id="modalAceptarBtn">Aceptar</button>
                <button id="modalCancelarBtn">Cancelar</button>
            </div>
        </div>
    </div>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/showdown/2.1.0/showdown.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js"
        xintegrity="sha512-vDnqY12kF+30rx1J1/yYkRb1sJmJ/R5h30V0fC6wzK+9J80/32Y6M+j692sY6F6w5kK3e9iXN7zHq8yW4+9Vw=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js"
        xintegrity="sha512-nL+yR6gCg+1X0s89QfC62Kq0L0N2i3J6mY/6d5q3g1K0K2W18w5+6L/w/6xQ5y2E8f5mO98i5M5j5L5w=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <script>
        // Get references to DOM elements
        const chatContainer = document.getElementById('chat-container');
        const inputContainer = document.getElementById('input-container'); // Added for toggling
        const bottomButtonsContainer = document.getElementById('bottom-buttons-container'); // Added for toggling
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const fileInput = document.getElementById('file-input');
        const readButton = document.getElementById('read-button');
        const downloadPdfButton = document.getElementById('download-pdf-button');
        const fontSizeSelector = document.getElementById('font-size'); // Still needed

        // Elements of the file menu
        const archivosButton = document.getElementById('archivos-button');
        const archivoMenu = document.getElementById('archivo-menu');
        const archivosLista = document.getElementById('archivos-lista');
        const archivoSubir = document.getElementById('archivo-subir');
        const archivoSubirInput = document.getElementById('archivo-subir-input');
        const binaryPasteTextarea = document.getElementById('binary-paste-textarea');
        const closeMenuButton = document.getElementById('close-menu-button');

        // HTML Preview elements
        const tabButtonFiles = document.getElementById('tab-button-files');
        const tabButtonHtmlPreview = document.getElementById('tab-button-html-preview');
        const tabContentFiles = document.getElementById('tab-content-files');
        const tabContentHtmlPreview = document.getElementById('tab-content-html-preview');
        const htmlPreviewTextarea = document.getElementById('html-preview-textarea');
        const htmlPreviewIframe = document.getElementById('html-preview-iframe');
        const openHtmlNewTabButton = document.getElementById('open-html-new-tab-button');
        const htmlDataUrlDisplay = document.getElementById('html-data-url-display'); // New element
        const dataUrlTextSpan = document.getElementById('data-url-text'); // NEW: Span to hold the actual data URL text
        const copyDataUrlButton = document.getElementById('copy-data-url-button'); // READDED: Copy Data URL button
        const openDataUrlButton = document.getElementById('open-data-url-button'); // NEW button
        const downloadHtmlButton = document.getElementById('download-html-button'); // NEW button

        // New Web Searches elements
        const tabButtonWebSearches = document.getElementById('tab-button-web-searches');
        const tabContentWebSearches = document.getElementById('tab-content-web-searches');
        const googleSearchSuggestionsContainer = document.getElementById('google-search-suggestions-container');
        const webSearchSourcesList = document.getElementById('web-search-sources-list');

        // Report elements
        const reportButton = document.getElementById('report-button');
        const deepReportButton = document.getElementById('deep-report-button'); // Renamed to Advanced Report button conceptually

        // HTML Mode elements (now controls HTML filtering)
        const htmlModeButton = document.getElementById('html-mode-button');

        // Image Mode elements
        const imageModeButton = document.getElementById('image-mode-button');
        const image4Container = document.getElementById('image-4-container');

        // Schema Mode elements
        const schemaModeButton = document.getElementById('schema-mode-button'); // New button reference

        // Fullscreen HTML Modal elements
        const fullscreenHtmlModal = document.getElementById('fullscreen-html-modal');
        const fullscreenHtmlIframe = document.getElementById('fullscreen-html-iframe');
        const closeFullscreenModalButton = document.getElementById('close-fullscreen-modal-button');

        // Advanced Report Mode Elements
        const tabButtonAdvancedReport = document.getElementById('tab-button-advanced-report');
        const tabContentAdvancedReport = document.getElementById('tab-content-advanced-report');
        const reportPlanList = document.getElementById('report-plan-list');
        const reportProgressBar = document.getElementById('report-progress-bar');
        const startReportPlanButton = document.getElementById('start-report-plan-button');
        const resetReportPlanButton = document.getElementById('reset-report-plan-button');
        const newStepInput = document.getElementById('new-step-input');
        const addStepButton = document.getElementById('add-step-button');

        // NEW URL Context Elements (now integrated into tab-content-files)
        const urlInput = document.getElementById('url-input'); 
        const addUrlButton = document.getElementById('add-url-button'); 
        const urlList = document.getElementById('url-list'); 
        const retrievedUrlList = document.getElementById('retrieved-url-list'); // NEW: for URL retrieval status display

        // MODIFIED: Thinking Tab elements (updated IDs)
        const tabButtonThinking = document.getElementById('tab-button-thinking');
        const tabContentThinking = document.getElementById('tab-content-thinking');
        const thinkingModeToggle = document.getElementById('thinking-mode-toggle'); // Updated ID
        const setThinkingBudgetToggle = document.getElementById('set-thinking-budget-toggle'); // Updated ID
        const thinkingBudgetSlider = document.getElementById('thinking-budget-slider'); // Updated ID
        const thinkingBudgetValue = document.getElementById('thinking-budget-value'); // Updated ID
        const budgetSliderContainer = document.getElementById('budget-slider-container'); // Updated ID


        // API Key for Gemini.
        const apiKey = 'AIzaSyD2Z5cvFOrS7fiHBY2KymJ7dT4UgmYOrVA';
        // Changed Gemini model to gemini-2.5-flash
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${apiKey}`;


        let history = []; // Stores the chat history for the Gemini API
        let showdownConverter; // Declare globally, initialize in window.onload
        let isReportModeActive = false; // State for report mode
        let isAdvancedReportModeActive = false; // New state for advanced report mode
        let isHtmlModeActive = false; // Controls HTML filtering
        let isImage4ModeActive = false; // State for Image 4 mode
        let isSchemaModeActive = false; // New state for schema mode

        // Modified reportPlan structure: each step is an object with text, selected, and completed status
        let reportPlan = []; // [{ text: 'Step 1', selected: true, completed: false }, ...]
        let currentReportStepIndex = 0; // Tracks the current step in the advanced report plan
        let reportTopic = ''; // Stores the topic for the advanced report
        let isExecutingReportPlan = false; // Flag to indicate if the report plan is in progress
        let waitingForDoubtResponse = false; // Flag for doubt interaction

        let draggedItem = null; // For drag and drop functionality

        // Array to store URLs for context
        let contextUrls = [];

        // Image 4 Specific JavaScript (Global declarations)
        const imagenGenerada = document.getElementById("imagenGenerada");
        const generarImagenBtn = document.getElementById("generarImagen");
        const mensajeInputImg4 = document.getElementById("mensajeInputImg4");
        const variarImagenBtn = document.getElementById("variarImagen");
        const variacionAlgoritmicaBtn = document.getElementById("variacionAlgoritmica");
        const pararVariacionBtn = document.getElementById("pararVariacion");
        const galeriaImagenes = document.getElementById("galeriaImagenes");
        const verBibliotecaBtn = document.getElementById("verBiblioteca");
        const ocultarBibliotecaBtn = document.getElementById("ocultarBiblioteca");
        const descargarImagenBtn = document.getElementById("descargarImagenPrincipal");
        const descargarGaleriaBtn = document.getElementById("descargarGaleria");
        const descargarSeleccionadasBtn = document.getElementById("descargarSeleccionadas");
        const modeloSelector = document.getElementById("modeloSelector");
        const userMessageDiv = document.getElementById("userMessage");
        const configurarDimensionesBtn = document.getElementById("configurarDimensionesBtn");
        const configModal = document.getElementById("configModal");
        const modalAnchoInput = document.getElementById("modalAnchoInput");
        const modalAltoInput = document.getElementById("modalAltoInput");
        const enhanceCheckbox = document.getElementById("enhanceCheckbox");
        const modalAceptarBtn = document.getElementById("modalAceptarBtn");
        const modalCancelarBtn = document.getElementById("modalCancelarBtn");
        const backToChatButton = document.getElementById("backToChatButton");

        // Image 4 - Variables para almacenar las dimensiones y el estado de mejora configurados globalmente
        let currentImageWidth = 512;
        let currentImageHeight = 512;
        let isEnhanceEnabled = false;

        let currentSeed = 0;
        let generacionContinua;


        // Define retry prompts and max retries for Gemini's HTML generation
        const HTML_RETRY_PROMPTS = [
            "Por favor, genera el código HTML completo, incluyendo `<!DOCTYPE html>`, `<html>`, `<head>`, y `<body>`. Asegúrate de que no haya texto explicativo adicional fuera de las etiquetas de código HTML.",
            "Necesito el HTML completo y autocontenido. Asegúrate de que sea un documento HTML válido y no incluyas ningún texto que no sea parte del código HTML.",
            "Proporciona el HTML completo, empezando con `<!DOCTYPE html>`. Elimina cualquier texto de introducción o conclusión, solo el código HTML.",
            "Intenta de nuevo y genera solo el código HTML completo y bien formado. No añadas comentarios ni texto fuera del bloque de código HTML.",
            "Genera únicamente el código HTML completo, sin envoltorios de Markdown ni explicaciones. Debe ser un archivo HTML listo para usar."
        ];
        const MAX_RETRIES = 5;
        const HTML_GENERATION_INSTRUCTION = "Genera todo el código HTML sin explicaciones, solo el código, empezando por `<!DOCTYPE html>`.";


        /**
         * Renders mathematical expressions within the chat container using KaTeX.
         * Ensures that `renderMathInElement` is defined before use.
         */
        function renderMath() {
            if (typeof renderMathInElement !== 'undefined') {
                renderMathInElement(chatContainer, {
                    delimiters: [
                        { left: '$$', right: '$$', display: true },
                        { left: '$', right: '$', display: false },
                        { left: '\\(', right: '\\)', display: false },
                        { left: '\\[', right: '\\]', display: true }
                    ],
                    throwOnError: false
                });
            } else {
                console.warn('renderMathInElement is not defined. KaTeX rendering may not work.');
            }
        };

        /**
         * Applies basic syntax highlighting to code within Markdown blocks.
         * @param {string} text - The code text to highlight.
         * @returns {string} The HTML string with highlighted code.
         */
        function highlightCode(text) {
            text = text.replace(/(const|let|var|function|return|if|else|for|while|switch|case|break|continue|try|catch|finally|class|extends|super|import|export|this|new|await|async)/g, '<span class="keyword">$1</span>');
            text = text.replace(/(['"])(.*?)(['"])/g, '<span class="string">$1$2$3</span>');
            text = text.replace(/(\/\/.*)/g, '<span class="comment">$1</span>');
            text = text.replace(/(\/\*[\s\S]*?\*\/)/g, '<span class="comment">$1</span>'); // Multi-line comments
            text = text.replace(/(\b\d+\.?\d*|\.\d+\b)/g, '<span class="number">$1</span>'); // Numbers
            return text;
        };

        /**
         * Plays audio for a given text using the browser's SpeechSynthesisUtterance API.
         * Used for the general "Escuchar" button that reads out chat history.
         * @param {string} text - The text to be spoken.
         * @param {HTMLElement} buttonElement - The button element to manage its disabled state and text.
         */
        async function playBrowserAudioForText(text, buttonElement) {
            if (!text) {
                console.log('No text to play.');
                return;
            }

            if (buttonElement) {
                buttonElement.disabled = true;
                buttonElement.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Generando...';
            }

            const utterance = new SpeechSynthesisUtterance(text);
            // Removed specific voice selection for chat. Will use default browser voice.
            utterance.onend = () => {
                if (buttonElement) {
                    buttonElement.disabled = false;
                    buttonElement.innerHTML = '<i class="fas fa-volume-up"></i> Escuchar'; // Restore original text
                }
            };

            utterance.onerror = (event) => {
                console.error('SpeechSynthesisUtterance.onerror', event);
                if (buttonElement) {
                    buttonElement.disabled = false;
                    buttonElement.innerHTML = '<i class="fas fa-volume-up"></i> Escuchar'; // Restore original text
                }
            };

            speechSynthesis.speak(utterance);
        };


        /**
         * Displays a system message in the chat interface.
         * @param {string} messageText - The text of the message to display.
         */
        function displaySystemMessage(messageText) {
            const systemMessageDiv = document.createElement('div');
            systemMessageDiv.className = 'gemini-message'; // Use gemini-message style for system messages
            systemMessageDiv.textContent = messageText;
            chatContainer.appendChild(systemMessageDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
        };

        /**
         * Updates the placeholder text of the message input field based on the active mode.
         */
        function updateInputPlaceholder() {
            if (isReportModeActive) {
                messageInput.placeholder = "Escribe las indicaciones de tu informe";
            } else if (isAdvancedReportModeActive) {
                messageInput.placeholder = "Escribe el tema para el informe avanzado y luego presiona 'Comenzar Plan de Informe'";
            }
            else if (isSchemaModeActive) {
                messageInput.placeholder = "Escribe el tema para generar un esquema interactivo (ej. 'diagrama de flujo sobre el ciclo del agua'). La respuesta que debe generar es un código de esquema.";
            } else {
                messageInput.placeholder = "Escribe tu mensaje...";
            }
        };

        /**
         * Sends a message to Gemini specifically for HTML generation with retry logic.
         * @param {string} messageToSendToGemini - The full prompt text to send to Gemini.
         * @param {string} originalUserMessage - The original message typed by the user.
         * @param {Array<Object>} currentFileDataArray - Array of file data objects for the current message.
         * @param {number} retryCount - The current retry attempt number.
         */
        async function sendToGeminiForHtmlOnly(messageToSendToGemini, originalUserMessage, currentFileDataArray, retryCount = 0) {
            let promptText = messageToSendToGemini;
            if (retryCount > 0) {
                promptText = HTML_RETRY_PROMPTS[retryCount - 1]; // Use specific retry prompts
                console.log(`Intentando HTML de nuevo (Intento ${retryCount + 1}): ${promptText.substring(0, 100)}...`);
            }

            let payloadContents = JSON.parse(JSON.stringify(history)); // Deep copy

            let finalPromptText = promptText;
            if (contextUrls.length > 0) {
                const urlsForPrompt = contextUrls.join('\n');
                finalPromptText = `Considera las siguientes URLs como contexto: ${urlsForPrompt}\n\n${promptText}`;
            }

            if (payloadContents.length > 0 && payloadContents[payloadContents.length - 1].role === 'user') {
                payloadContents[payloadContents.length - 1].parts = [{ text: finalPromptText }];
                if (currentFileDataArray && currentFileDataArray.length > 0) {
                    currentFileDataArray.forEach(file => {
                        payloadContents[payloadContents.length - 1].parts.push({
                            inlineData: {
                                mimeType: file.mimeType,
                                data: file.data
                            }
                        });
                    });
                }
            } else {
                const userParts = [{ text: finalPromptText }];
                if (currentFileDataArray && currentFileDataArray.length > 0) {
                    currentFileDataArray.forEach(file => {
                        userParts.push({
                            inlineData: {
                                mimeType: file.mimeType,
                                data: file.data
                            }
                        });
                    });
                }
                payloadContents.push({ role: 'user', parts: userParts });
            }

            const tools = [{ googleSearch: {} }];
            if (contextUrls.length > 0) {
                tools.push({ urlContext: {} });
            }

            try {
                const payload = {
                    contents: payloadContents,
                    generationConfig: {
                        temperature: 1,
                        topP: 0.95,
                        topK: 40,
                        maxOutputTokens: 8192,
                    },
                    tools: tools,
                };

                console.log("Enviando a Gemini para HTML:", JSON.stringify(payload));
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(payload),
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('API response not OK (Gemini HTML generation):', response.status, response.statusText, errorText);
                    throw new Error(`API error (Gemini HTML generation): ${response.status} ${response.statusText} - ${errorText}`);
                }

                const data = await response.json();
                console.log("Raw Gemini HTML Response Data:", JSON.stringify(data, null, 2));

                if (data.candidates && data.candidates.length > 0 && data.candidates[0].content && data.candidates[0].content.parts && data.candidates[0].content.parts.length > 0) {
                    let geminiResponse = data.candidates[0].content.parts[0].text;
                    console.log("Extracted Gemini HTML Response Text:", geminiResponse);

                    // Robustly extract HTML content, handling markdown code blocks and surrounding text
                    let htmlContent = geminiResponse;
                    const htmlCodeBlockMatch = geminiResponse.match(/```html\n([\s\S]*?)\n```/);
                    if (htmlCodeBlockMatch && htmlCodeBlockMatch[1]) {
                        htmlContent = htmlCodeBlockMatch[1].trim();
                    } else if (geminiResponse.includes('<!DOCTYPE html>')) {
                        // If no markdown block, try to find the start of HTML
                        const docTypeIndex = geminiResponse.indexOf('<!DOCTYPE html>');
                        if (docTypeIndex !== -1) {
                            htmlContent = geminiResponse.substring(docTypeIndex).trim();
                        }
                    }

                    const hasHtmlDocType = htmlContent.includes('<!DOCTYPE html>');

                    if (hasHtmlDocType) {
                        htmlPreviewTextarea.value = htmlContent;
                        // Update the text content of the span inside html-data-url-display
                        dataUrlTextSpan.textContent = `data:text/html;charset=utf-8,${encodeURIComponent(htmlContent)}`;
                        const iframeDoc = htmlPreviewIframe.contentWindow.document;
                        iframeDoc.open();
                        iframeDoc.write(htmlContent);
                        iframeDoc.close();
                        showTab('tab-content-html-preview');
                        
                        let displayMessage = `Aquí está el código HTML generado:\n\n\`\`\`html\n${htmlContent.substring(0, 500)}...\n\`\`\`\n\nVerifica la pestaña 'Previsualizar HTML' para la visualización completa.`;

                        let responseHtml = showdownConverter.makeHtml(displayMessage);
                        responseHtml = responseHtml.replace(/(-b ± √(b² - 4ac)) \/ 2a/g, '<span class="katex">\\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}</span>');
                        responseHtml = responseHtml.replace(/x\^2/g, '<span class="katex">x^2</span>');
                        responseHtml = responseHtml.replace(/a\/b/g, '<span class="katex">\\frac{a}{b}</span>');
                        responseHtml = responseHtml.replace(/\\sqrt\{(\w+)\}/g, '<span class="katex">\\sqrt{$1}</span>');
                        responseHtml = responseHtml.replace(/\\sqrt\{(b\^2 - 4ac)\}/g, '<span class="katex">\\sqrt{b^2 - 4ac}</span>');
                        responseHtml = responseHtml.replace(/(\\frac\{\w+\}\{\w+\})/g, '<span class="katex">$1</span>');
                        responseHtml = responseHtml.replace(/<pre><code[^>]*>([\s\S]*?)<\/code><\/pre>/g, (match, code) => {
                            const highlightedCode = highlightCode(code.trim());
                            return `<pre><code class="code-block">${highlightedCode}</code></pre>`;
                        });

                        history.push({ role: 'model', parts: [{ text: displayMessage }] });

                        const geminiMessageDiv = document.createElement('div');
                        geminiMessageDiv.className = 'gemini-message';
                        geminiMessageDiv.innerHTML = responseHtml;
                        chatContainer.appendChild(geminiMessageDiv);
                        chatContainer.scrollTop = chatContainer.scrollHeight;
                        renderMath();

                        fileDataArray = [];
                        fileInput.value = '';
                        renderAllUploadedLists();
                    } else {
                        if (retryCount < MAX_RETRIES) {
                            displaySystemMessage(`La respuesta no contenía HTML completo. Reintentando (intento ${retryCount + 1}/${MAX_RETRIES})...`);
                            history.push({ role: 'model', parts: [{ text: `Respuesta de Gemini (no HTML completo): ${geminiResponse.substring(0, 200)}...` }] });
                            await sendToGeminiForHtmlOnly(originalUserMessage, originalUserMessage, currentFileDataArray, retryCount + 1);
                        } else {
                            displaySystemMessage('Gemini no pudo generar HTML completo después de varios intentos. Aquí está la respuesta recibida:');
                            let responseHtml = showdownConverter.makeHtml(geminiResponse);
                            responseHtml = responseHtml.replace(/(-b ± √(b² - 4ac)) \/ 2a/g, '<span class="katex">\\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}</span>');
                            responseHtml = responseHtml.replace(/x\^2/g, '<span class="katex">x^2</span>');
                            responseHtml = responseHtml.replace(/a\/b/g, '<span class="katex">\\frac{a}{b}</span>');
                            responseHtml = responseHtml.replace(/\\sqrt\{(\w+)\}/g, '<span class="katex">\\sqrt{$1}</span>');
                            responseHtml = responseHtml.replace(/\\sqrt\{(b\^2 - 4ac)\}/g, '<span class="katex">\\sqrt{b^2 - 4ac}</span>');
                            responseHtml = responseHtml.replace(/(\\frac\{\w+\}\{\w+\})/g, '<span class="katex">$1</span>');
                            responseHtml = responseHtml.replace(/<pre><code[^>]*>([\s\S]*?)<\/code><\/pre>/g, (match, code) => {
                                const highlightedCode = highlightCode(code.trim());
                                return `<pre><code class="code-block">${highlightedCode}</code></pre>`;
                            });

                            history.push({ role: 'model', parts: [{ text: geminiResponse }] });

                            const geminiMessageDiv = document.createElement('div');
                            geminiMessageDiv.className = 'gemini-message';
                            geminiMessageDiv.innerHTML = responseHtml;
                            chatContainer.appendChild(geminiMessageDiv);
                            chatContainer.scrollTop = chatContainer.scrollHeight;
                            renderMath();
                        }
                    }

                    // NEW: Process and display URL context metadata
                    if (data.candidates[0].urlContextMetadata) {
                        renderUrlContextMetadata(data.candidates[0].urlContextMetadata.url_metadata);
                    }


                    if (data.candidates[0].groundingMetadata) {
                        const groundingMetadata = data.candidates[0].groundingMetadata;
                        if (groundingMetadata.searchEntryPoint && groundingMetadata.searchEntryPoint.renderedContent) {
                            googleSearchSuggestionsContainer.innerHTML = groundingMetadata.searchEntryPoint.renderedContent;
                        }
                        if (groundingMetadata.groundingChunks && groundingMetadata.groundingChunks.length > 0) {
                            webSearchSourcesList.innerHTML = '';
                            groundingMetadata.groundingChunks.forEach(chunk => {
                                if (chunk.web && chunk.web.uri && chunk.web.title) {
                                    const listItem = document.createElement('li');
                                    const link = document.createElement('a');
                                    link.href = chunk.web.uri;
                                    link.textContent = chunk.web.title;
                                    link.target = '_blank';
                                    listItem.appendChild(link);
                                    webSearchSourcesList.appendChild(listItem);
                                }
                            });
                        }
                        if (googleSearchSuggestionsContainer.innerHTML || webSearchSourcesList.innerHTML) {
                            archivoMenu.classList.add('active');
                            showTab('tab-content-web-searches');
                        }
                    }

                } else {
                    displaySystemMessage('Error: Gemini no pudo obtener una respuesta para la generación de HTML.');
                    console.error('No candidates found in Gemini HTML response:', data);
                }
            } catch (error) {
                console.error('Error al enviar mensaje a Gemini para HTML:', error);
                displaySystemMessage('Error: nuestro servidor falló al generar HTML. Por favor, inténtalo de nuevo.');
                messageInput.value = originalUserMessage;
            }
        };

        // This will store all collected search results and their sources during the deep report process.
        let allSearchResults = [];
        let allSearchSources = new Set(); // Using a Set to store unique source URLs

        /**
         * Generates the advanced report plan based on the given topic.
         * @param {string} topic - The topic for the advanced report.
         */
        async function generateAdvancedReportPlan(topic) {
            displaySystemMessage('Generando plan de investigación para un informe avanzado...');
            console.log('Generando plan de investigación para un informe avanzado sobre:', topic);

            // Refined prompt for plan generation
            const planPrompt = `Genera un plan de 5 a 7 pasos claros y concisos para un informe profundo sobre "${topic}". Cada paso debe ser una acción específica, por ejemplo:
            1. Buscar información general sobre [tema].
            2. Analizar subtemas clave como [subtema1] y [subtema2].
            3. Identificar y formular preguntas de investigación sobre [tema].
            4. Realizar búsquedas detalladas para responder a las preguntas.
            5. Sintetizar la información recopilada y estructurar el informe.
            6. Redactar el informe completo con conclusiones y webgrafía.
            7. Revisar y refinar el informe para claridad y precisión.
            
            Proporciona solo una lista numerada de los pasos, sin texto introductorio ni explicaciones adicionales fuera de los puntos de la lista.`;

            const planPayload = {
                contents: [{ role: 'user', parts: [{ text: planPrompt }] }],
                generationConfig: {
                    temperature: 0.7,
                    maxOutputTokens: 2048, // Increased from 500 to 2048
                },
            };
            try {
                console.log("Enviando a Gemini para generar plan de informe:", JSON.stringify(planPayload));
                const planResponse = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(planPayload) });
                
                if (!planResponse.ok) {
                    const errorText = await planResponse.text();
                    console.error('API response not OK (Generate Report Plan):', planResponse.status, planResponse.statusText, errorText);
                    throw new Error(`API error (Generate Report Plan): ${planResponse.status} ${planResponse.statusText} - ${errorText}`);
                }

                const planData = await planResponse.json();
                console.log("Raw Gemini Plan Data:", JSON.stringify(planData, null, 2));

                if (planData.candidates && planData.candidates.length > 0 && planData.candidates[0].content && planData.candidates[0].content.parts && planData.candidates[0].content.parts.length > 0) {
                    let rawPlanText = planData.candidates[0].content.parts[0].text.trim();
                    console.log("Extracted Raw Plan Text:", rawPlanText);

                    // Extract actual list items, handling potential intro text
                    const planLines = rawPlanText.split('\n').filter(line => line.trim().match(/^\d+\./));

                    reportPlan = planLines.map(step => {
                        return { text: step.replace(/^\d+\.\s*/, '').trim(), selected: true, completed: false };
                    });
                    
                    if (reportPlan.length === 0) {
                        displaySystemMessage('No se pudo generar un plan de informe válido. Por favor, intenta con un tema más específico o reformula la solicitud.');
                        resetReportPlan();
                        return;
                    }

                    console.log('Plan de investigación generado:');
                    reportPlan.forEach(step => console.log(step.text));
                    displaySystemMessage('Plan de informe generado. Presiona "Comenzar Plan de Informe" para iniciar la ejecución.');
                    displayReportPlan(); // Show plan in the UI
                    startReportPlanButton.disabled = false; // Enable start button
                    resetReportPlanButton.disabled = false; // Enable reset button
                } else {
                    displaySystemMessage('Error: No se pudo obtener un plan de informe de Gemini. Por favor, intenta de nuevo.');
                    console.error('No candidates or content found in Gemini plan response:', planData);
                    resetReportPlan();
                }
            } catch (error) { // Added catch block
                console.error('Error al generar el plan de informe:', error);
                displaySystemMessage('Error al generar el plan de informe. Por favor, inténtalo de nuevo.');
                resetReportPlan(); // Reset if plan generation fails
            }
        };

        /**
         * Displays the current report plan in the UI, including checkboxes and drag-and-drop functionality.
         */
        function displayReportPlan() {
            reportPlanList.innerHTML = '';
            reportPlan.forEach((stepObj, index) => {
                const listItem = document.createElement('li');
                listItem.classList.add('report-plan-item'); // Add a class for styling/selection
                listItem.draggable = true; // Make items draggable
                listItem.dataset.index = index; // Store original index

                listItem.innerHTML = `
            <input type="checkbox" id="step-checkbox-${index}" data-index="${index}" ${stepObj.selected ? 'checked' : ''} ${stepObj.completed ? 'disabled' : ''}>
            <span contenteditable="true" data-index="${index}" class="report-step-text">${stepObj.text}</span>
        `;
                if (stepObj.completed) {
                    listItem.classList.add('completed');
                }
                reportPlanList.appendChild(listItem);
            });
            updateProgressBar();

            // Add event listeners for checkboxes and contenteditable spans
            reportPlanList.querySelectorAll('.report-plan-item input[type="checkbox"]').forEach(checkbox => {
                checkbox.addEventListener('change', (event) => {
                    const index = parseInt(event.target.dataset.index);
                    reportPlan[index].selected = event.target.checked;
                    updateProgressBar(); // Update progress based on selected steps
                });
            });

            reportPlanList.querySelectorAll('.report-plan-item .report-step-text').forEach(span => {
                span.addEventListener('input', (event) => {
                    const index = parseInt(event.target.dataset.index);
                    reportPlan[index].text = event.target.textContent;
                });
            });

            // Add drag and drop event listeners
            reportPlanList.querySelectorAll('.report-plan-item').forEach(item => {
                item.addEventListener('dragstart', handleDragStart);
                item.addEventListener('dragover', handleDragOver);
                item.addEventListener('dragleave', handleDragLeave); // New listener for visual feedback
                item.addEventListener('drop', handleDrop);
                item.addEventListener('dragend', handleDragEnd);
            });
        };

        /**
         * Handles the dragstart event for report plan items, setting up the dragged item.
         * @param {DragEvent} e - The drag event.
         */
        function handleDragStart(e) {
            draggedItem = e.target;
            e.dataTransfer.effectAllowed = 'move';
            // Use setTimeout to ensure the class is applied after the browser captures the element for dragging
            setTimeout(() => {
                draggedItem.classList.add('dragging');
            }, 0);
        }

        /**
         * Handles the dragover event for report plan items, allowing dropping and providing visual feedback.
         * @param {DragEvent} e - The drag event.
         */
        function handleDragOver(e) {
            e.preventDefault(); // Necessary to allow a drop
            e.dataTransfer.dropEffect = 'move';
            // Add visual feedback for where the item will be dropped
            const targetItem = e.target.closest('.report-plan-item');
            if (targetItem && targetItem !== draggedItem) {
                const rect = targetItem.getBoundingClientRect();
                const offsetY = e.clientY - rect.top;
                if (offsetY < rect.height / 2) {
                    targetItem.style.borderTop = '2px solid #007bff';
                    targetItem.style.borderBottom = 'none';
                } else {
                    targetItem.style.borderBottom = '2px solid #007bff';
                    targetItem.style.borderTop = 'none';
                }
            }
        }

        /**
         * Handles the dragleave event for report plan items, removing visual feedback.
         * @param {DragEvent} e - The drag event.
         */
        function handleDragLeave(e) {
            const targetItem = e.target.closest('.report-plan-item');
            if (targetItem) {
                targetItem.style.borderTop = 'none';
                targetItem.style.borderBottom = 'none';
            }
        }

        /**
         * Handles the drop event for report plan items, reordering the plan.
         * @param {DragEvent} e - The drag event.
         */
        function handleDrop(e) {
            e.preventDefault();
            const targetItem = e.target.closest('.report-plan-item');
            if (targetItem && draggedItem && targetItem !== draggedItem) {
                const draggedIndex = Array.from(reportPlanList.children).indexOf(draggedItem);
                const targetIndex = Array.from(reportPlanList.children).indexOf(targetItem);

                const draggedData = reportPlan[draggedIndex];

                // Remove the dragged item from its original position
                reportPlan.splice(draggedIndex, 1);

                // Determine new index based on drop position
                const rect = targetItem.getBoundingClientRect();
                const offsetY = e.clientY - rect.top;
                let newIndex = targetIndex;
                if (offsetY > rect.height / 2) {
                    newIndex = targetIndex + 1;
                }

                // Insert the dragged item into its new position
                reportPlan.splice(newIndex, 0, draggedData);

                // Re-render the plan to reflect the new order and update data-index
                displayReportPlan();
            }

            // Clean up drop target styles
            if (targetItem) {
                targetItem.style.borderTop = 'none';
                targetItem.style.borderBottom = 'none';
            }
        }

        /**
         * Handles the dragend event for report plan items, cleaning up after dragging.
         * @param {DragEvent} e - The drag event.
         */
        function handleDragEnd(e) {
            // Remove dragging class from the dragged item
            draggedItem.classList.remove('dragging');
            draggedItem = null; // Clear dragged item reference
            // Ensure all items have their border styles removed
            reportPlanList.querySelectorAll('.report-plan-item').forEach(item => {
                item.style.borderTop = 'none';
                item.style.borderBottom = 'none';
            });
        }


        /**
         * Updates the progress bar based on the completion status of selected report plan steps.
         */
        function updateProgressBar() {
            const totalSelectedSteps = reportPlan.filter(step => step.selected).length;
            const completedSelectedSteps = reportPlan.filter(step => step.selected && step.completed).length;
            const progressPercentage = totalSelectedSteps === 0 ? 0 : (completedSelectedSteps / totalSelectedSteps) * 100;

            reportProgressBar.style.width = `${progressPercentage}%`;
            reportProgressBar.textContent = `${Math.round(progressPercentage)}%`;

            if (progressPercentage === 100 && totalSelectedSteps > 0) {
                displaySystemMessage('¡Informe avanzado completado!');
                isExecutingReportPlan = false;
                startReportPlanButton.disabled = true;
                resetReportPlanButton.disabled = false;
            } else if (isExecutingReportPlan && totalSelectedSteps > 0 && completedSelectedSteps === totalSelectedSteps) {
                displaySystemMessage('Todos los pasos seleccionados han sido completados.');
                isExecutingReportPlan = false;
                startReportPlanButton.disabled = true;
                resetReportPlanButton.disabled = false;
            }
        };

        /**
         * Resets the advanced report mode, clearing the plan and UI elements.
         */
        function resetReportPlan() {
            reportPlan = [];
            currentReportStepIndex = 0;
            reportTopic = '';
            isExecutingReportPlan = false;
            waitingForDoubtResponse = false;
            allSearchResults = [];
            allSearchSources = new Set();
            reportPlanList.innerHTML = '';
            reportProgressBar.style.width = '0%';
            reportProgressBar.textContent = '0%';
            startReportPlanButton.disabled = true;
            resetReportPlanButton.disabled = true;
            newStepInput.value = '';
            displaySystemMessage('Modo Informe Avanzado reiniciado. Introduce un nuevo tema para comenzar.');
            updateInputPlaceholder();
        };

        /**
         * Executes the next selected and uncompleted step in the advanced report plan.
         */
        async function executeReportPlanStep() {
            let nextStepObj = null;
            let nextStepIndex = -1;
            for (let i = currentReportStepIndex; i < reportPlan.length; i++) {
                if (reportPlan[i].selected && !reportPlan[i].completed) {
                    nextStepObj = reportPlan[i];
                    nextStepIndex = i;
                    break;
                }
            }

            if (nextStepObj === null) {
                updateProgressBar();
                isExecutingReportPlan = false;
                startReportPlanButton.disabled = true;
                resetReportPlanButton.disabled = false;
                return;
            }

            currentReportStepIndex = nextStepIndex;
            const currentStepText = nextStepObj.text;

            displaySystemMessage(`Ejecutando paso ${currentReportStepIndex + 1}: ${currentStepText}...`);
            console.log(`Ejecutando paso ${currentReportStepIndex + 1}: ${currentStepText}`);

            const checkbox = document.getElementById(`step-checkbox-${currentReportStepIndex}`);
            const listItem = checkbox ? checkbox.parentElement : null;
            if (checkbox) {
                checkbox.checked = true;
                checkbox.disabled = true;
                if (listItem) {
                    listItem.classList.add('completed');
                }
            }
            reportPlan[currentReportStepIndex].completed = true;
            updateProgressBar();

            if (currentStepText.includes('Buscar información general')) {
                const searchPrompt = `Buscar información general y relevante sobre "${reportTopic}". Resumir en 2-3 frases clave y listar 3-5 URLs importantes.`;
                await performGoogleSearch([searchPrompt], "general");
                await executeReportPlanStep();
            } else if (currentStepText.includes('Analizar subtemas clave')) {
                const collectedTextForSubtopics = allSearchResults.map(result => result.snippet || '').join(' ').substring(0, 3000); // Use collected info
                const subtopicPrompt = `Dado el tema principal "${reportTopic}" y la siguiente información: "${collectedTextForSubtopics}", identifica 2-3 subtemas clave para profundizar, relacionados con este paso: "${currentStepText}". Lista solo los subtemas separados por comas y sin explicaciones.`;
                try {
                    const subtopicPayload = {
                        contents: [{ role: 'user', parts: [{ text: subtopicPrompt }] }],
                        generationConfig: { temperature: 0.5, maxOutputTokens: 200 },
                    };
                    console.log("Enviando a Gemini para subtemas:", JSON.stringify(subtopicPayload));
                    const subtopicResponse = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(subtopicPayload) });
                    
                    if (!subtopicResponse.ok) {
                        const errorText = await subtopicResponse.text();
                        console.error('API response not OK (Subtopic Generation):', subtopicResponse.status, subtopicResponse.statusText, errorText);
                        throw new Error(`API error (Subtopic Generation): ${subtopicResponse.status} ${subtopicResponse.statusText} - ${errorText}`);
                    }

                    const subtopicData = await subtopicResponse.json();
                    console.log("Raw Gemini Subtopic Data:", JSON.stringify(subtopicData, null, 2));

                    const subtopicsText = subtopicData.candidates[0]?.content?.parts[0]?.text?.trim();
                    const subtopics = subtopicsText ? subtopicsText.split(',').map(s => s.trim()).filter(s => s) : [];

                    if (subtopics.length > 0) {
                        displaySystemMessage(`Profundizando en los subtemas: ${subtopics.join(', ')}. Realizando búsquedas detalladas.`);
                        const subtopicQueries = subtopics.map(st => `información detallada y ejemplos de ${st} en relación con ${reportTopic}`);
                        await performGoogleSearch(subtopicQueries, "subtopic"); // Use "subtopic" type for queries
                    } else {
                        displaySystemMessage('No se pudieron identificar subtemas para profundizar. Continuando sin búsquedas adicionales por subtemas.');
                    }
                } catch (error) {
                    console.error('Error al profundizar en subtemas:', error);
                    displaySystemMessage('Error al profundizar en subtemas. Continuando.');
                }
                await executeReportPlanStep();

            } else if (currentStepText.includes('Identificar y formular preguntas de investigación')) {
                waitingForDoubtResponse = true;
                displaySystemMessage('Generando posibles preguntas de investigación...');
                const collectedTextForDoubts = allSearchResults.map(result => result.snippet || '').join(' ').substring(0, 4000); // More text
                const doubtsPrompt = `Dado el tema "${reportTopic}" y la información recopilada hasta ahora (primeros 4000 caracteres de snippets: "${collectedTextForDoubts}"), genera 3-5 preguntas de investigación (dudas) cruciales para un informe profundo, relacionadas con el paso del plan: "${currentStepText}". Formato: "- Pregunta". No incluyas explicaciones ni texto introductorio/final.`;

                try {
                    const doubtsPayload = {
                        contents: [{ role: 'user', parts: [{ text: doubtsPrompt }] }],
                        generationConfig: { temperature: 0.7, maxOutputTokens: 300 },
                    };
                    console.log("Enviando a Gemini para preguntas:", JSON.stringify(doubtsPayload));
                    const doubtsResponse = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(doubtsPayload) });
                    
                    if (!doubtsResponse.ok) {
                        const errorText = await doubtsResponse.text();
                        console.error('API response not OK (Question Generation):', doubtsResponse.status, doubtsResponse.statusText, errorText);
                        throw new Error(`API error (Question Generation): ${doubtsResponse.status} ${doubtsResponse.statusText} - ${errorText}`);
                    }

                    const doubtsData = await doubtsResponse.json();
                    console.log("Raw Gemini Questions Data:", JSON.stringify(doubtsData, null, 2));

                    const generatedDoubtsText = doubtsData.candidates[0]?.content?.parts[0]?.text?.trim();
                    const generatedDoubts = generatedDoubtsText ? generatedDoubtsText.split('\n').filter(line => line.trim().startsWith('-')) : [];

                    if (generatedDoubts.length > 0) {
                        let doubtsHtml = "Aquí tienes algunas preguntas que la IA ha generado para profundizar en la investigación:\n\n";
                        generatedDoubts.forEach(d => doubtsHtml += `${d}\n`);
                        displaySystemMessage(doubtsHtml);
                        console.log('Preguntas generadas:', generatedDoubts);
                        // Store these questions if needed for later targeted searches.
                    } else {
                        displaySystemMessage('La IA no pudo generar preguntas de investigación válidas. Continuando con el siguiente paso.');
                    }
                    await executeReportPlanStep();

                } catch (error) {
                    console.error('Error al generar preguntas:', error);
                    displaySystemMessage('Error al generar preguntas. Continuando con el siguiente paso.');
                    waitingForDoubtResponse = false;
                    await executeReportPlanStep();
                }

            } else if (currentStepText.includes('Realizar búsquedas detalladas para responder a las preguntas')) {
                const searchQueriesFromHistory = history.filter(item => item.role === 'model' && item.parts[0].text.includes('Aquí tienes algunas preguntas')).flatMap(item =>
                    item.parts[0].text.split('\n').filter(line => line.startsWith('- ')).map(line => line.substring(2).trim())
                );
                
                let targetedQueries = [];
                if (searchQueriesFromHistory.length > 0) {
                    targetedQueries = searchQueriesFromHistory.map(q => `respuesta a la pregunta: "${q}" sobre ${reportTopic}`);
                } else {
                    // Fallback if no specific questions were generated
                    targetedQueries = [`información a fondo sobre ${reportTopic}`, `investigación avanzada de ${reportTopic}`];
                }

                if (targetedQueries.length > 0) {
                    displaySystemMessage('Realizando búsquedas detalladas para responder a las preguntas...');
                    await performGoogleSearch(targetedQueries.slice(0, 5), "detailed"); // Limit to a few queries
                } else {
                    displaySystemMessage('No hay preguntas o fuentes claras para búsquedas adicionales. Saltando este paso.');
                }
                await executeReportPlanStep();

            } else if (currentStepText.includes('Sintetizar la información recopilada y estructurar el informe.')) {
                displaySystemMessage('Sintetizando y estructurando la información para el informe...');
                // This step doesn't involve new searches, just processing existing `allSearchResults`
                await executeReportPlanStep();

            } else if (currentStepText.includes('Redactar el informe completo con conclusiones y webgrafía')) {
                displaySystemMessage('Redactando el informe detallado...');
                const fullCollectedText = allSearchResults.map(result => result.snippet || '').join('\n\n');
                const sourcesFormatted = Array.from(allSearchSources).map(url => `- [${url}](${url})`).join('\n'); // Markdown format for links

                const finalReportPrompt = `Basándote en TODA la información recopilada sobre "${reportTopic}", redacta un informe profundo y detallado. Organiza la información de manera lógica con subtítulos claros. Incluye una introducción, secciones de desarrollo que aborden los subtemas y preguntas investigadas, y una sección de conclusiones. El informe debe ser coherente y fácil de entender. Al final, proporciona una webgrafía completa con todos los enlaces visitados.
        \nInformación recopilada (snippets): \n${fullCollectedText.substring(0, 10000)}` // Increased context
                    + `\n\nWebgrafía completa (asegúrate de que los enlaces estén activos y correctos, y que la lista sea de enlaces reales de fuentes, si se ha usado la herramienta de búsqueda): \n${sourcesFormatted || 'No se encontraron fuentes de búsqueda web.'}`;

                try {
                    const finalReportPayload = {
                        contents: [{ role: 'user', parts: [{ text: finalReportPrompt }] }],
                        generationConfig: {
                            temperature: 0.7,
                            topP: 0.95,
                            topK: 40,
                            maxOutputTokens: 8192,
                        },
                        tools: [{ googleSearch: {} }], // Keep tools enabled for potential internal use by Gemini
                    };

                    console.log("Enviando a Gemini para informe final:", JSON.stringify(finalReportPayload));
                    const finalReportResponse = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(finalReportPayload) });
                    
                    if (!finalReportResponse.ok) {
                        const errorText = await finalReportResponse.text();
                        console.error('API response not OK (Final Report Generation):', finalReportResponse.status, finalReportResponse.statusText, errorText);
                        throw new Error(`API error (Final Report Generation): ${finalReportResponse.status} ${finalReportResponse.statusText} - ${errorText}`);
                    }

                    const finalReportData = await finalReportResponse.json();
                    console.log("Raw Gemini Final Report Data:", JSON.stringify(finalReportData, null, 2));

                    let finalReportText = finalReportData.candidates[0]?.content?.parts[0]?.text || 'No se pudo generar el informe final.';

                    console.log('Informe Final Generado:', finalReportText);
                    displaySystemMessage('Informe completo generado y añadido al chat.');

                    let responseHtml = showdownConverter.makeHtml(finalReportText);
                    responseHtml = responseHtml.replace(/(-b ± √(b² - 4ac)) \/ 2a/g, '<span class="katex">\\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}</span>');
                    responseHtml = responseHtml.replace(/x\^2/g, '<span class="katex">x^2</span>');
                    responseHtml = responseHtml.replace(/a\/b/g, '<span class="katex">\\frac{a}{b}</span>');
                    responseHtml = responseHtml.replace(/\\sqrt\{(\w+)\}/g, '<span class="katex">\\sqrt{$1}</span>');
                    responseHtml = responseHtml.replace(/\\sqrt\{(b\^2 - 4ac)\}/g, '<span class="katex">\\sqrt{b^2 - 4ac}</span>');
                    responseHtml = responseHtml.replace(/(\\frac\{\w+\}\{\w+\})/g, '<span class="katex">$1</span>');
                    responseHtml = responseHtml.replace(/<pre><code[^>]*>([\s\S]*?)<\/code><\/pre>/g, (match, code) => {
                        const highlightedCode = highlightCode(code.trim());
                        return `<pre><code class="code-block">${highlightedCode}</code></pre>`;
                    });

                    const geminiMessageDiv = document.createElement('div');
                    geminiMessageDiv.className = 'gemini-message';
                    geminiMessageDiv.innerHTML = responseHtml;
                    chatContainer.appendChild(geminiMessageDiv);
                    chatContainer.scrollTop = chatContainer.scrollHeight;
                    renderMath();

                    history.push({ role: 'model', parts: [{ text: finalReportText }] });

                } catch (error) {
                    console.error('Error al redactar el informe:', error);
                    displaySystemMessage('Error al redactar el informe. Por favor, revisa la consola para más detalles.');
                }
                updateProgressBar();
                isExecutingReportPlan = false;
                startReportPlanButton.disabled = true;
                resetReportPlanButton.disabled = false;
            } else if (currentStepText.includes('Revisar y refinar el informe para claridad y precisión')) {
                displaySystemMessage('Revisando y refinando el informe final. Esto se hace de forma interna. Si deseas un cambio específico, por favor, indícalo.');
                // In a real application, you might prompt Gemini again for a refinement pass
                // based on criteria or a general "make it better" prompt.
                // For this example, we just mark it as complete.
                await executeReportPlanStep();
            }
            else {
                console.warn(`Paso desconocido o personalizado: "${currentStepText}". Marcando como completado y avanzando.`);
                // If a step is not recognized, mark it as completed and move on.
                reportPlan[currentReportStepIndex].completed = true;
                updateProgressBar();
                await executeReportPlanStep();
            }
        };

        // Event listener for adding a new step
        addStepButton.addEventListener('click', () => {
            const newStepText = newStepInput.value.trim();
            if (newStepText) {
                reportPlan.push({ text: newStepText, selected: true, completed: false });
                displayReportPlan();
                newStepInput.value = '';
                startReportPlanButton.disabled = false;
            } else {
                displaySystemMessage('Por favor, introduce texto para el nuevo paso.');
            }
        });


        /**
         * Sends a message to the Gemini API, handling different modes (report, HTML, schema)
         * and including file data and URL context.
         * @param {string} message - The user's message.
         * @param {Array<Object>} currentFileDataArray - An array of file data objects to send with the message.
         */
        async function sendMessage(message, currentFileDataArray) {
            const userMessageDiv = document.createElement('div');
            userMessageDiv.className = 'user-message';
            let messageHtml = showdownConverter.makeHtml(message);
            userMessageDiv.innerHTML = messageHtml;

            chatContainer.appendChild(userMessageDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;

            // Clear previous search results and sources on new general chat message
            if (!isAdvancedReportModeActive && !isSchemaModeActive && !isHtmlModeActive) {
                googleSearchSuggestionsContainer.innerHTML = '';
                webSearchSourcesList.innerHTML = '';
                allSearchResults = []; // Clear for new conversation context
                allSearchSources.clear(); // Clear for new conversation context
            }
            
            let messageToPushToHistory = message;
            if (contextUrls.length > 0) {
                const urlsForPrompt = contextUrls.join('\n');
                messageToPushToHistory = `Considera las siguientes URLs como contexto: ${urlsForPrompt}\n\n${message}`;
            }

            history.push({ role: 'user', parts: [{ text: messageToPushToHistory }] });

            try {
                if (isAdvancedReportModeActive && !isExecutingReportPlan) {
                    reportTopic = message;
                    displaySystemMessage(`Modo Informe Avanzado activado. Tema: "${reportTopic}". Generando plan...`);
                    await generateAdvancedReportPlan(reportTopic);
                } else if (isAdvancedReportModeActive && isExecutingReportPlan && waitingForDoubtResponse) {
                    waitingForDoubtResponse = false;
                    displaySystemMessage(`Recibida tu respuesta sobre las dudas. Si es una duda, realizaré una búsqueda. De lo contrario, continuaré con el informe.`);
                    // If the user's message is a follow-up to doubts, process it or just continue
                    // For now, we'll assume a "continue" and let the next executeReportPlanStep handle it.
                    await executeReportPlanStep();
                }
                else if (isSchemaModeActive) {
                    await generarEsquemaInteractivoHTML(message);
                } else if (isHtmlModeActive) {
                    const fullHtmlPrompt = HTML_GENERATION_INSTRUCTION + message;
                    await sendToGeminiForHtmlOnly(fullHtmlPrompt, message, currentFileDataArray);
                } else {
                    let payloadContents = JSON.parse(JSON.stringify(history)); // Deep copy
                    let lastUserMessageIndex = -1;
                    for (let i = payloadContents.length - 1; i >= 0; i--) {
                        if (payloadContents[i].role === 'user') {
                            lastUserMessageIndex = i;
                            break;
                        }
                    };

                    if (lastUserMessageIndex !== -1) {
                        let currentMessageText = payloadContents[lastUserMessageIndex].parts[0].text;
                        if (isReportModeActive) {
                            const reportPrefix = "Genera un informe detallado y entendible sobre ";
                            currentMessageText = reportPrefix + currentMessageText + ". Incluye la webgrafía de los sitios visitados, si los hay, en formato de lista Markdown.";
                        }
                        payloadContents[lastUserMessageIndex].parts = [{ text: currentMessageText }];

                        if (currentFileDataArray && currentFileDataArray.length > 0) {
                            currentFileDataArray.forEach(file => {
                                payloadContents[lastUserMessageIndex].parts.push({
                                    inlineData: {
                                        mimeType: file.mimeType,
                                        data: file.data
                                    }
                                });
                            });
                        }
                    }

                    const tools = [{ googleSearch: {} }];
                    if (contextUrls.length > 0) {
                        tools.push({ urlContext: {} });
                    }
                    
                    // MODIFIED: Add thinkingConfig if enabled
                    const isThinkingEnabled = thinkingModeToggle.checked; // Use new ID
                    const thinkingBudget = isThinkingEnabled && setThinkingBudgetToggle.checked ? parseInt(thinkingBudgetSlider.value, 10) : (isThinkingEnabled ? -1 : 0); // Use new IDs and logic for budget

                    const payload = {
                        contents: payloadContents,
                        generationConfig: {
                            temperature: 1,
                            topP: 0.95,
                            topK: 40,
                            maxOutputTokens: 8192,
                        },
                        tools: tools,
                    };

                    if (isThinkingEnabled) {
                        payload.generationConfig.thinkingConfig = {
                            thinkingBudget: thinkingBudget,
                            includeThoughts: true // Always include thoughts if thinking is enabled
                        };
                    }

                    console.log("Enviando a Gemini (modo normal):", JSON.stringify(payload));
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(payload),
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error('API response not OK (normal mode):', response.status, response.statusText, errorText);
                        throw new Error(`API error: ${response.status} ${response.statusText} - ${errorText}`);
                    }

                    const data = await response.json();
                    console.log("Raw Gemini Response Data (normal mode):", JSON.stringify(data, null, 2));

                    if (data.candidates && data.candidates.length > 0 && data.candidates[0].content && data.candidates[0].content.parts && data.candidates[0].content.parts.length > 0) {
                        let geminiResponse = '';
                        let thoughtContent = '';

                        // Iterate through all parts to find the thought and main response
                        for (const part of data.candidates[0].content.parts) {
                            if (part.thought && part.text) { // If the part is a thought and has text
                                thoughtContent = part.text; // Save the thought text
                            } else if (part.text) { // If it's a normal text part (main response)
                                geminiResponse += part.text; // Accumulate main response parts
                            }
                        }
                        
                        console.log("Extracted Gemini Response Text (normal mode):", geminiResponse);
                        if (thoughtContent) {
                            console.log("Extracted Gemini Thought Content:", thoughtContent);
                        }

                        // NEW: Process and display URL context metadata
                        if (data.candidates[0].urlContextMetadata) {
                            renderUrlContextMetadata(data.candidates[0].urlContextMetadata.url_metadata);
                        }


                        if (data.candidates[0].groundingMetadata) {
                            const groundingMetadata = data.candidates[0].groundingMetadata;
                            if (groundingMetadata.searchEntryPoint && groundingMetadata.searchEntryPoint.renderedContent) {
                                googleSearchSuggestionsContainer.innerHTML = groundingMetadata.searchEntryPoint.renderedContent;
                            }
                            if (groundingMetadata.groundingChunks && groundingMetadata.groundingChunks.length > 0) {
                                webSearchSourcesList.innerHTML = '';
                                groundingMetadata.groundingChunks.forEach(chunk => {
                                    if (chunk.web && chunk.web.uri && chunk.web.title) {
                                        const listItem = document.createElement('li');
                                        const link = document.createElement('a');
                                        link.href = chunk.web.uri;
                                        link.textContent = chunk.web.title;
                                        link.target = '_blank';
                                        listItem.appendChild(link);
                                        webSearchSourcesList.appendChild(listItem);
                                    }
                                });
                            }
                            if (googleSearchSuggestionsContainer.innerHTML || webSearchSourcesList.innerHTML) {
                                archivoMenu.classList.add('active');
                                showTab('tab-content-web-searches');
                            }
                        }

                        if (isReportModeActive) {
                            const sourcesHtml = webSearchSourcesList.innerHTML;
                            if (sourcesHtml) {
                                // Ensure sources are added to the report text consistently
                                let newSourcesText = "\n\n**Webgrafía de sitios visitados:**\n";
                                const tempDiv = document.createElement('div');
                                tempDiv.innerHTML = sourcesHtml;
                                Array.from(tempDiv.querySelectorAll('li a')).forEach(link => {
                                    newSourcesText += `- [${link.textContent}](${link.href})\n`;
                                });
                                geminiResponse += newSourcesText;
                            }
                        }

                        const geminiMessageDiv = document.createElement('div');
                        geminiMessageDiv.className = 'gemini-message';

                        // If there's thought content, create the button and hidden thought div
                        if (thoughtContent) {
                            const thoughtToggleButton = document.createElement('button');
                            thoughtToggleButton.className = 'thought-toggle-button';
                            thoughtToggleButton.textContent = 'Pensamiento';
                            geminiMessageDiv.appendChild(thoughtToggleButton);

                            const thoughtDiv = document.createElement('div');
                            thoughtDiv.className = 'model-thought hidden'; // Hidden by default
                            thoughtDiv.innerHTML = `<strong>Pensamiento:</strong> ${showdownConverter.makeHtml(thoughtContent)}`;
                            geminiMessageDiv.appendChild(thoughtDiv);

                            thoughtToggleButton.addEventListener('click', () => {
                                console.log('Thought button clicked! Toggling visibility.'); // Debugging line
                                thoughtDiv.classList.toggle('hidden');
                            });
                        }
                        
                        // MODIFIED: Create a new div for the main response and append it
                        let responseHtml = showdownConverter.makeHtml(geminiResponse);
                        responseHtml = responseHtml.replace(/(-b ± √(b² - 4ac)) \/ 2a/g, '<span class="katex">\\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}</span>');
                        responseHtml = responseHtml.replace(/x\^2/g, '<span class="katex">x^2</span>');
                        responseHtml = responseHtml.replace(/a\/b/g, '<span class="katex">\\frac{a}{b}</span>');
                        responseHtml = responseHtml.replace(/\\sqrt\{(\w+)\}/g, '<span class="katex">\\sqrt{$1}</span>');
                        responseHtml = responseHtml.replace(/\\sqrt\{(b\^2 - 4ac)\}/g, '<span class="katex">\\sqrt{b^2 - 4ac}</span>');
                        responseHtml = responseHtml.replace(/(\\frac\{\w+\}\{\w+\})/g, '<span class="katex">$1</span>');
                        responseHtml = responseHtml.replace(/<pre><code[^>]*>([\s\S]*?)<\/code><\/pre>/g, (match, code) => {
                            const highlightedCode = highlightCode(code.trim());
                            return `<pre><code class="code-block">${highlightedCode}</code></pre>`;
                        });

                        const mainResponseDiv = document.createElement('div');
                        mainResponseDiv.innerHTML = responseHtml;
                        geminiMessageDiv.appendChild(mainResponseDiv); // Append the main response as a new div

                        chatContainer.appendChild(geminiMessageDiv);
                        chatContainer.scrollTop = chatContainer.scrollHeight;
                        renderMath();

                        history.push({ role: 'model', parts: [{ text: geminiResponse }] });

                        fileDataArray = [];
                        fileInput.value = '';
                        renderAllUploadedLists();
                    } else {
                        const errorDiv = document.createElement('div');
                        errorDiv.className = 'gemini-message';
                        errorDiv.textContent = 'Error: No se pudo obtener una respuesta del modelo.';
                        chatContainer.appendChild(errorDiv);
                        chatContainer.scrollTop = chatContainer.scrollHeight;
                        console.error('No candidates or content found in Gemini normal mode response:', data);
                    }
                }
            } catch (error) {
                console.error('Error al enviar mensaje:', error);
                const errorDiv = document.createElement('div');
                errorDiv.className = 'gemini-message';
                errorDiv.textContent = `Error: nuestro servidor falló. ${error.message}`;
                chatContainer.appendChild(errorDiv);
                chatContainer.scrollTop = chatContainer.scrollHeight;
                messageInput.value = message;
            }
        };

        /**
         * Performs a Google search based on provided queries and updates the UI with results and sources.
         * @param {Array<string>} queries - An array of search queries.
         * @param {string} searchType - A string indicating the type of search (e.g., "general", "subtopic", "detailed").
         */
        async function performGoogleSearch(queries, searchType = "general") {
            // Clear previous search results and sources specifically for the UI display, but keep them for advanced report accumulation
            googleSearchSuggestionsContainer.innerHTML = '';
            webSearchSourcesList.innerHTML = '';

            let searchPromptText = `Realiza las siguientes búsquedas en Google: ${queries.join(', ')}. Proporciona los snippets y URLs relevantes.`;
            if (contextUrls.length > 0) {
                const urlsForPrompt = contextUrls.join('\n');
                searchPromptText = `Considera las siguientes URLs como contexto: ${urlsForPrompt}\n\n${searchPromptText}`;
            }

            const tools = [{ googleSearch: {} }];
            if (contextUrls.length > 0) {
                tools.push({ urlContext: {} });
            }

            const searchPayload = {
                contents: [{
                    role: "user",
                    parts: [{
                        text: searchPromptText
                    }]
                }],
                tools: tools,
            };

            try {
                displaySystemMessage(`Realizando búsqueda (${searchType})...`);
                console.log("Enviando a Gemini para búsqueda:", JSON.stringify(searchPayload));
                const searchResponse = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(searchPayload)
                });

                if (!searchResponse.ok) {
                    const errorText = await searchResponse.text();
                    console.error('API response not OK (Google Search):', searchResponse.status, searchResponse.statusText, errorText);
                    throw new Error(`API error (Google Search): ${searchResponse.status} ${searchResponse.statusText} - ${errorText}`);
                }

                const searchData = await searchResponse.json();
                console.log("Raw Google Search Data:", JSON.stringify(searchData, null, 2));

                if (searchData.candidates && searchData.candidates.length > 0 && searchData.candidates[0].groundingMetadata) {
                    const groundingMetadata = searchData.candidates[0].groundingMetadata;

                    if (groundingMetadata.searchEntryPoint && groundingMetadata.searchEntryPoint.renderedContent) {
                        googleSearchSuggestionsContainer.innerHTML = groundingMetadata.searchEntryPoint.renderedContent;
                    }

                    if (groundingMetadata.groundingChunks && groundingMetadata.groundingChunks.length > 0) {
                        groundingMetadata.groundingChunks.forEach(chunk => {
                            if (chunk.web) {
                                allSearchResults.push({ snippet: chunk.web.snippet, url: chunk.web.uri });
                                allSearchSources.add(chunk.web.uri); // Add to the set for unique sources
                            }
                        });

                        // Re-render the web search sources list with all accumulated unique sources
                        webSearchSourcesList.innerHTML = '';
                        Array.from(allSearchSources).forEach(url => {
                            const listItem = document.createElement('li');
                            const link = document.createElement('a');
                            link.href = url;
                            link.textContent = url;
                            link.target = '_blank';
                            listItem.appendChild(link);
                            webSearchSourcesList.appendChild(listItem);
                        });
                    }
                    archivoMenu.classList.add('active');
                    showTab('tab-content-web-searches');
                    displaySystemMessage(`Búsqueda (${searchType}) completada. Resultados disponibles en la pestaña 'Búsquedas Web'.`);
                } else {
                    console.warn('No se encontraron resultados de búsqueda o metadatos de fundamentación.');
                    displaySystemMessage(`No se pudo realizar la búsqueda (${searchType}) o no se encontraron resultados relevantes.`);
                }
            } catch (error) {
                console.error('Error al realizar la búsqueda en Google:', error);
                displaySystemMessage(`Error al realizar la búsqueda (${searchType}): ${error.message}`);
            }
        };

        let fileDataArray = []; // Files attached for the current message
        const uploadedFiles = []; // All files uploaded during the conversation

        // Event listener for send button click
        sendButton.addEventListener('click', () => {
            const message = messageInput.value.trim();

            if (message || fileDataArray.length > 0) {
                sendMessage(message, [...fileDataArray]);
                messageInput.value = '';
            }
        });

        // Event listener for Enter key in message input
        messageInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                sendButton.click();
                event.preventDefault();
            }
        });

        // Event listener for pasting content into the message input
        messageInput.addEventListener('paste', async (event) => {
            const items = event.clipboardData?.items;
            if (!items) return;

            event.preventDefault();

            let filesProcessed = false;
            let pastedText = '';

            for (const item of items) {
                if (item.type.startsWith('image/')) {
                    const file = item.getAsFile();
                    if (file) {
                        const uniqueFileName = `pasted_image_${crypto.randomUUID()}.${file.type.split('/')[1] || 'png'}`;
                        const uniqueFile = new File([file], uniqueFileName, { type: file.type });
                        processFiles([uniqueFile]);
                        filesProcessed = true;
                    }
                } else if (item.type === 'text/plain') {
                    pastedText = event.clipboardData.getData('text/plain');
                }
            }

            if (pastedText && !filesProcessed) {
                messageInput.value += pastedText;
            }

            if (filesProcessed) {
                archivoMenu.classList.add('active');
                showTab('tab-content-files');
                messageInput.value = '';
            }
        });

        // Event listener for the "Escuchar" (Listen) button
        readButton.addEventListener('click', () => {
            const messages = document.querySelectorAll('.user-message, .gemini-message');
            let fullText = '';
            messages.forEach(message => {
                fullText += message.textContent + '. ';
            });

            // Use browser's built-in TTS for the general "Listen" button
            playBrowserAudioForText(fullText, readButton); // No longer passing voice name directly, it's from chatVoiceSelect
        });

        // Event listener for the "Descargar PDF" (Download PDF) button
        downloadPdfButton.addEventListener('click', () => {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();

            let yPos = 10;
            const margin = 10;
            const pageWidth = doc.internal.pageSize.width;
            const pageHeight = doc.internal.pageSize.height;
            const maxWidth = pageWidth - 2 * margin;

            function addWrappedText(text, x, y, maxWidth, doc, isBold = false) {
                doc.setFont("helvetica", isBold ? "bold" : "normal");
                const textLines = doc.splitTextToSize(text, maxWidth);
                let currentY = y;

                for (const line of textLines) {
                    if (currentY + doc.getTextDimensions(line).h > pageHeight - margin) {
                        doc.addPage();
                        currentY = margin;
                    }
                    doc.text(line, x, currentY);
                    currentY += doc.getTextDimensions(line).h + 2;
                }
                return currentY - y;
            }

            const messages = document.querySelectorAll('.user-message, .gemini-message');
            messages.forEach(message => {
                let messageText = message.textContent;
                const isUserMessage = message.classList.contains('user-message');

                const textHeight = addWrappedText(messageText, margin, yPos, maxWidth, doc, isUserMessage);
                yPos += textHeight + 5;
            });

            doc.save('chat_conversation.pdf');
        });

        // Function to update the font size of the chat messages
        fontSizeSelector.addEventListener('change', (event) => {
            const selectedFontSize = event.target.value + 'px';
            chatContainer.style.fontSize = selectedFontSize;
        });

        // Removed: Event listener for font family input
        // fontFamilyInput.addEventListener('input', (event) => {
        //     const selectedFontFamily = event.target.value.trim();
        //     chatContainer.style.fontFamily = selectedFontFamily;
        // });

        /**
         * Renders all uploaded files and URLs in the "Fuentes" list within the file menu.
         */
        function renderAllUploadedLists() {
            archivosLista.innerHTML = ''; // Clear the files list

            // Render uploaded files
            uploadedFiles.forEach((file, index) => {
                const listItem = document.createElement('li');
                listItem.innerHTML = `
                    <span>${file.name}</span>
                    <div class="archivo-iconos">
                        <a href="#" data-index="${index}" class="reattach-file" title="Volver a adjuntar">&#x21BA;</a>
                        <a href="#" data-index="${index}" class="delete-file" title="Eliminar">&#x1F5D1;</a>
                    </div>
                `;
                archivosLista.appendChild(listItem);
            });

            // Render URLs
            urlList.innerHTML = ''; // Clear the URL list before rendering
            contextUrls.forEach((url, index) => {
                const listItem = document.createElement('li');
                listItem.classList.add('url-item');
                listItem.innerHTML = `
                    <a href="${url}" target="_blank">${url}</a>
                    <button class="delete-url-button" data-index="${index}">Eliminar</button>
                `;
                urlList.appendChild(listItem);
            });
        };

        // Event listener to toggle the file menu visibility
        archivosButton.addEventListener('click', () => {
            archivoMenu.classList.toggle('active');
            if (archivoMenu.classList.contains('active')) {
                showTab('tab-content-files');
            }
        });

        // Event listener to close the file menu
        closeMenuButton.addEventListener('click', () => {
            archivoMenu.classList.remove('active');
        });

        // Event listener for file input change (from main chat interface)
        fileInput.addEventListener('change', (event) => {
            const files = event.target.files;
            if (files.length > 0) {
                processFiles(files);
            }
        });

        // Event listener for clicking the "Arrastra y suelta" area to open file input
        archivoSubir.addEventListener('click', (event) => {
            archivoSubirInput.click();
        });

        // Event listener for file input change (from file menu)
        archivoSubirInput.addEventListener('change', (event) => {
            const files = event.target.files;
            if (files.length > 0) {
                processFiles(files);
            }
        });

        /**
         * Processes selected or dropped files, converting them to Base64 and storing them.
         * This function now handles files from folder uploads as well.
         * @param {FileList} files - The list of File objects to process.
         */
        function processFiles(files) {
            for (const file of files) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const newFile = {
                        name: file.webkitRelativePath || file.name, // Use webkitRelativePath for folder structure
                        mimeType: file.type,
                        data: e.target.result.split(',')[1], // Base64 encoded data
                        url: e.target.result // Full data URL for local display (e.g., thumbnails)
                    };
                    const existingFileInCurrentMessage = fileDataArray.find(f => f.name === newFile.name && f.mimeType === newFile.mimeType && f.data === newFile.data);
                    if (!existingFileInCurrentMessage) {
                        fileDataArray.push(newFile);
                    }

                    const existingFileInUploaded = uploadedFiles.find(f => f.name === newFile.name && f.mimeType === newFile.mimeType);
                    if (!existingFileInUploaded) {
                        uploadedFiles.push(newFile);
                    }
                    renderAllUploadedLists();
                };
                reader.readAsDataURL(file);
            }
        };

        // Drag and drop event listeners for the file upload area
        archivoSubir.addEventListener('dragover', (event) => {
            event.preventDefault();
            archivoSubir.style.backgroundColor = '#e0e0e0';
        });

        archivoSubir.addEventListener('dragleave', (event) => {
            archivoSubir.style.backgroundColor = 'transparent';
        });

        archivoSubir.addEventListener('drop', (event) => {
            event.preventDefault();
            archivoSubir.style.backgroundColor = 'transparent';
            const files = event.dataTransfer.files;
            if (files.length > 0) {
                processFiles(files);
            }
        });

        // Event listener for actions within the uploaded files list (reattach/delete)
        archivosLista.addEventListener('click', (event) => {
            if (event.target.classList.contains('reattach-file')) {
                event.preventDefault();
                const index = parseInt(event.target.dataset.index);
                const fileToReattach = uploadedFiles[index];
                if (fileToReattach) {
                    const existingFileInCurrentMessage = fileDataArray.find(f => f.name === fileToReattach.name && f.mimeType === fileToReattach.mimeType && f.data === fileToReattach.data);
                    if (!existingFileInCurrentMessage) {
                        fileDataArray.push(fileToReattach);
                    }
                    displaySystemMessage(`Archivo adjuntado de nuevo: ${fileToReattach.name}`);
                }
            } else if (event.target.classList.contains('delete-file')) {
                event.preventDefault();
                const index = parseInt(event.target.dataset.index);
                const fileToDelete = uploadedFiles[index];

                if (fileToDelete) {
                    uploadedFiles.splice(index, 1);
                    let i = fileDataArray.length;
                    while (i--) {
                        if (fileDataArray[i].name === fileToDelete.name && fileDataArray[i].mimeType === fileToDelete.mimeType && fileDataArray[i].data === fileToDelete.data) {
                            fileDataArray.splice(i, 1);
                        }
                    }
                    renderAllUploadedLists();
                    displaySystemMessage(`Archivo eliminado: ${fileToDelete.name}`);
                } else {
                    console.error('Archivo no encontrado para eliminación en el índice:', index);
                }
            }
        });

        /**
         * Shows the specified tab content within the file menu and activates its corresponding button.
         * @param {string} tabId - The ID of the tab content to show (e.g., 'tab-content-files').
         */
        function showTab(tabId) {
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active-tab-content');
            });
            document.querySelectorAll('.tab-buttons').forEach(button => {
                button.classList.remove('active-tab');
            });

            document.getElementById(tabId).classList.add('active-tab-content');

            if (tabId === 'tab-content-files') {
                tabButtonFiles.classList.add('active-tab');
            } else if (tabId === 'tab-content-html-preview') {
                tabButtonHtmlPreview.classList.add('active-tab');
            } 
            else if (tabId === 'tab-content-web-searches') {
                tabButtonWebSearches.classList.add('active-tab');
            } else if (tabId === 'tab-content-advanced-report') {
                tabButtonAdvancedReport.classList.add('active-tab');
            } else if (tabId === 'tab-content-thinking') { 
                tabButtonThinking.classList.add('active-tab');
            }
        };

        // Event listeners for tab buttons
        tabButtonFiles.addEventListener('click', () => showTab('tab-content-files'));
        tabButtonHtmlPreview.addEventListener('click', () => showTab('tab-content-html-preview'));
        tabButtonWebSearches.addEventListener('click', () => showTab('tab-content-web-searches'));
        tabButtonAdvancedReport.addEventListener('click', () => showTab('tab-content-advanced-report'));
        tabButtonThinking.addEventListener('click', () => showTab('tab-content-thinking')); 


        // Event listener for binary paste textarea
        binaryPasteTextarea.addEventListener('paste', (event) => {
            const items = event.clipboardData?.items;
            if (!items) return;

            event.preventDefault();

            let filesProcessed = false;
            for (const item of items) {
                if (item.type.startsWith('image/')) {
                    const file = item.getAsFile();
                    if (file) {
                        const uniqueFileName = `pasted_image_${crypto.randomUUID()}.${file.type.split('/')[1] || 'png'}`;
                        const uniqueFile = new File([file], uniqueFileName, { type: file.type });
                        processFiles([uniqueFile]);
                        filesProcessed = true;
                    }
                } else if (item.type === 'text/plain') {
                    const pastedText = event.clipboardData.getData('text/plain');
                    if (pastedText.startsWith('data:') || (pastedText.length > 500 && pastedText.match(/^[a-zA-Z0-9+/=]+$/))) {
                        try {
                            const mimeTypeMatch = pastedText.match(/^data:([a-zA-Z0-9]+\/[a-zA-Z0-9-.+]+);base64,/);
                            if (mimeTypeMatch) {
                                const mimeType = mimeTypeMatch[1];
                                const base64Data = pastedText.split(',')[1];
                                const uniqueFileName = `pasted_data_${crypto.randomUUID()}.${mimeType.split('/')[1] || 'bin'}`;
                                const newFile = {
                                    name: uniqueFileName,
                                    mimeType: mimeType,
                                    data: base64Data,
                                    url: pastedText
                                };
                                fileDataArray.push(newFile);
                                uploadedFiles.push(newFile);
                                renderAllUploadedLists();
                                filesProcessed = true;
                            }
                        } catch (e) {
                            console.error("Error processing pasted base64 data:", e);
                        }
                    } else {
                        const currentText = binaryPasteTextarea.value;
                        binaryPasteTextarea.value = currentText + pastedText;
                    }
                }
            }
            if (filesProcessed) {
                binaryPasteTextarea.value = '';
            }
        });

        // Event listener for HTML preview textarea input
        htmlPreviewTextarea.addEventListener('input', () => {
            const htmlContent = htmlPreviewTextarea.value;
            const dataUrl = `data:text/html;charset=utf-8,${encodeURIComponent(htmlContent)}`;
            // Update the text content of the span inside html-data-url-display
            dataUrlTextSpan.textContent = dataUrl;
            const iframeDoc = htmlPreviewIframe.contentWindow.document;
            iframeDoc.open();
            iframeDoc.write(htmlContent);
            iframeDoc.close();
        });

        // Event listener for opening HTML in a new tab
        openHtmlNewTabButton.addEventListener('click', () => {
            const htmlContent = htmlPreviewTextarea.value;
            if (htmlContent) {
                const newWindow = window.open();
                newWindow.document.write(htmlContent);
                newWindow.document.close();
            } else {
                console.log('No HTML content to open.');
            }
        });

        // READDED: Event listener for Copy Data URL button
        copyDataUrlButton.addEventListener('click', () => {
            const dataUrl = dataUrlTextSpan.textContent;
            if (dataUrl) {
                const tempInput = document.createElement('textarea');
                tempInput.value = dataUrl;
                document.body.appendChild(tempInput);
                tempInput.select();
                try {
                    document.execCommand('copy');
                    displaySystemMessage('Data URL copiada al portapapeles.');
                } catch (err) {
                    console.error('No se pudo copiar el Data URL:', err);
                    displaySystemMessage('Error al copiar el Data URL.');
                }
                document.body.removeChild(tempInput);
            } else {
                displaySystemMessage('No hay Data URL para copiar.');
            }
        });

        // Modified: Event listener for Open Data URL button - now ONLY opens
        openDataUrlButton.addEventListener('click', () => {
            const dataUrl = dataUrlTextSpan.textContent;
            if (dataUrl && dataUrl.startsWith('data:')) {
                const newWindow = window.open(dataUrl, '_blank');
                if (!newWindow) {
                    displaySystemMessage('El navegador bloqueó la apertura de la nueva pestaña. Permite pop-ups.');
                }
            } else {
                displaySystemMessage('No hay Data URL válida para abrir.');
            }
        });

        // NEW: Event listener for Download HTML button
        downloadHtmlButton.addEventListener('click', () => {
            const htmlContent = htmlPreviewTextarea.value;
            if (htmlContent) {
                const blob = new Blob([htmlContent], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'generated_code.html';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url); // Clean up
                displaySystemMessage('Archivo HTML descargado.');
            } else {
                displaySystemMessage('No hay contenido HTML para descargar.');
            }
        });

        // Event listener for opening fullscreen HTML modal
        htmlPreviewIframe.addEventListener('click', () => {
            const htmlContent = htmlPreviewTextarea.value;
            if (htmlContent) {
                fullscreenHtmlIframe.srcdoc = htmlContent;
                fullscreenHtmlModal.classList.add('active');
            }
        });

        // Event listener for closing fullscreen HTML modal
        closeFullscreenModalButton.addEventListener('click', () => {
            fullscreenHtmlModal.classList.remove('active');
            fullscreenHtmlIframe.srcdoc = '';
        });

        // Event listener for Report button
        reportButton.addEventListener('click', () => {
            isReportModeActive = !isReportModeActive;
            reportButton.classList.toggle('report-active', isReportModeActive);

            if (isReportModeActive) {
                if (isAdvancedReportModeActive) {
                    isAdvancedReportModeActive = false;
                    deepReportButton.classList.remove('advanced-report-active');
                    resetReportPlan();
                }
                if (isHtmlModeActive) {
                    isHtmlModeActive = false;
                    htmlModeButton.classList.remove('html-active');
                }
                if (isImage4ModeActive) {
                    isImage4ModeActive = false;
                    imageModeButton.classList.remove('image-active');
                    showChatMode();
                }
                if (isSchemaModeActive) {
                    isSchemaModeActive = false;
                    schemaModeButton.classList.remove('schema-active');
                }
                console.log("Modo Informe activado.");
                displaySystemMessage("Modo Informe activado. Tu próximo mensaje se generará como un informe detallado con webgrafía (si aplica).");
            } else {
                console.log("Modo Informe desactivado.");
                displaySystemMessage("Modo Informe desactivado.");
            }
            updateInputPlaceholder();
        });

        // Event listener for Deep Report button (now Advanced Report)
        deepReportButton.addEventListener('click', () => {
            isAdvancedReportModeActive = !isAdvancedReportModeActive;
            deepReportButton.classList.toggle('advanced-report-active', isAdvancedReportModeActive);

            if (isAdvancedReportModeActive) {
                if (isReportModeActive) {
                    isReportModeActive = false;
                    reportButton.classList.remove('report-active');
                }
                if (isHtmlModeActive) {
                    isHtmlModeActive = false;
                    htmlModeButton.classList.remove('html-active');
                }
                if (isImage4ModeActive) {
                    isImage4ModeActive = false;
                    imageModeButton.classList.remove('image-active');
                    showChatMode();
                }
                if (isSchemaModeActive) {
                    isSchemaModeActive = false;
                    schemaModeButton.classList.remove('schema-active');
                }
                console.log("Modo Informe Avanzado activado.");
                displaySystemMessage("Modo Informe Avanzado activado. Por favor, escribe el tema del informe en la barra de mensajes para generar el plan.");
                archivoMenu.classList.add('active');
                showTab('tab-content-advanced-report');
                resetReportPlan();
            } else {
                console.log("Modo Informe Avanzado desactivado.");
                displaySystemMessage("Modo Informe Avanzado desactivado.");
                resetReportPlan();
            }
            updateInputPlaceholder();
        });

        // Event listener for Start Report Plan button
        startReportPlanButton.addEventListener('click', async () => {
            if (reportPlan.length > 0 && !isExecutingReportPlan) {
                if (reportPlan.some(step => step.selected)) {
                    isExecutingReportPlan = true;
                    startReportPlanButton.disabled = true;
                    resetReportPlanButton.disabled = true;
                    currentReportStepIndex = 0; // Always start from the first step after clicking Start
                    await executeReportPlanStep();
                } else {
                    displaySystemMessage('Selecciona al menos un paso en el plan para comenzar.');
                }
            } else if (isExecutingReportPlan) {
                displaySystemMessage('El plan de informe ya está en ejecución.');
            } else {
                displaySystemMessage('Primero, activa el Modo Informe Avanzado e introduce un tema para generar el plan.');
            }
        });

        // Event listener for Reset Report Plan button
        resetReportPlanButton.addEventListener('click', () => {
            resetReportPlan();
        });


        // Event listener for HTML Mode button (now for HTML filtering)
        htmlModeButton.addEventListener('click', () => {
            isHtmlModeActive = !isHtmlModeActive;
            htmlModeButton.classList.toggle('html-active', isHtmlModeActive);

            if (isHtmlModeActive) {
                if (isReportModeActive) {
                    isReportModeActive = false;
                    reportButton.classList.remove('report-active');
                }
                if (isAdvancedReportModeActive) {
                    isAdvancedReportModeActive = false;
                    deepReportButton.classList.remove('advanced-report-active');
                    resetReportPlan();
                }
                if (isImage4ModeActive) {
                    isImage4ModeActive = false;
                    imageModeButton.classList.remove('image-active');
                    showChatMode();
                }
                if (isSchemaModeActive) {
                    isSchemaModeActive = false;
                    schemaModeButton.classList.remove('schema-active');
                }
                console.log("Modo HTML activado.");
                displaySystemMessage("Modo HTML activado. Tu próximo mensaje intentará generar código HTML y previsualizarlo.");
            } else {
                console.log("Modo HTML desactivado.");
                displaySystemMessage("Modo HTML desactivado.");
            }
            updateInputPlaceholder();
        });

        // Event listener for Image Mode button
        imageModeButton.addEventListener('click', () => {
            isImage4ModeActive = !isImage4ModeActive;
            imageModeButton.classList.toggle('image-active', isImage4ModeActive);

            if (isImage4ModeActive) {
                if (isReportModeActive) {
                    isReportModeActive = false;
                    reportButton.classList.remove('report-active');
                }
                if (isAdvancedReportModeActive) {
                    isAdvancedReportModeActive = false;
                    deepReportButton.classList.remove('advanced-report-active');
                    resetReportPlan();
                }
                if (isHtmlModeActive) {
                    isHtmlModeActive = false;
                    htmlModeButton.classList.remove('html-active');
                    showChatMode();
                }
                if (isSchemaModeActive) {
                    isSchemaModeActive = false;
                    schemaModeButton.classList.remove('schema-active');
                }
                console.log("Modo Imagen 4 activado.");
                showImage4Mode();
            } else {
                console.log("Modo Imagen 4 desactivado.");
                showChatMode();
            }
            updateInputPlaceholder();
        });

        // Event listener for Schema Mode button
        schemaModeButton.addEventListener('click', () => {
            isSchemaModeActive = !isSchemaModeActive;
            schemaModeButton.classList.toggle('schema-active', isSchemaModeActive);

            if (isSchemaModeActive) {
                if (isReportModeActive) {
                    isReportModeActive = false;
                    reportButton.classList.remove('report-active');
                }
                if (isAdvancedReportModeActive) {
                    isAdvancedReportModeActive = false;
                    deepReportButton.classList.remove('advanced-report-active');
                    resetReportPlan();
                }
                if (isHtmlModeActive) {
                    isHtmlModeActive = false;
                    htmlModeButton.classList.remove('html-active');
                }
                if (isImage4ModeActive) {
                    isImage4ModeActive = false;
                    imageModeButton.classList.remove('image-active');
                    showChatMode();
                }
                console.log("Modo Esquema Interactivo activado.");
                displaySystemMessage("Modo Esquema Interactivo activado. Tus próximos mensajes generarán diagramas. Puedes especificar el tipo (ej. 'diagrama de flujo sobre...', 'diagrama de secuencia sobre...', etc.).");
            } else {
                console.log("Modo Esquema Interactivo desactivado.");
                displaySystemMessage("Modo Esquema Interactivo desactivado.");
            }
            updateInputPlaceholder();
        });


        /**
         * Shows the chat interface and hides the image generation interface.
         */
        function showChatMode() {
            chatContainer.style.display = 'flex';
            inputContainer.style.display = 'flex';
            bottomButtonsContainer.style.display = 'flex';
            image4Container.style.display = 'none';
            imageModeButton.classList.remove('image-active');
            isImage4ModeActive = false;
        };

        /**
         * Shows the image generation interface and hides the chat interface.
         */
        function showImage4Mode() {
            chatContainer.style.display = 'none';
            inputContainer.style.display = 'none';
            bottomButtonsContainer.style.display = 'none';
            image4Container.style.display = 'flex';
            initializeImage4App();
        };

        /**
         * Generates a random seed for image generation.
         * @returns {number} A random integer between 0 and 999,999.
         */
        function generarNumeroAleatorio() {
            return Math.floor(Math.random() * 1000000);
        };

        /**
         * Generates a URL for an image from Pollinations.ai based on message, seed, model, and current dimensions/enhance setting.
         * @param {string} mensaje - The prompt message for the image.
         * @param {number} seed - The seed for image variation.
         * @param {string} [modelo='flux'] - The image generation model.
         * @returns {string} The URL of the generated image.
         */
        function generarURLImagen(mensaje, seed, modelo = 'flux') {
            const finalWidth = parseInt(currentImageWidth) > 0 ? parseInt(currentImageWidth) : 512;
            const finalHeight = parseInt(currentImageHeight) > 0 ? parseInt(currentImageHeight) : 512;

            let url = `https://image.pollinations.ai/prompt/${encodeURIComponent(mensaje)}?width=${finalWidth}&height=${finalHeight}&seed=${seed}&model=${modelo}&nologo=true&referrer=fCLOsopMrBrtngvA`;

            if (isEnhanceEnabled) {
                url += '&enhance=true';
            }
            return url;
        };

        /**
         * Converts an image URL to a Data URL (Base64) by fetching it as a blob.
         * @param {string} url - The URL of the image to convert.
         * @param {function(string): void} callback - The callback function to receive the Data URL.
         */
        function convertirURLADataURL(url, callback) {
            const xhr = new XMLHttpRequest();
            xhr.onload = function () {
                if (xhr.status >= 200 && xhr.status < 300) {
                    const reader = new FileReader();
                    reader.onloadend = function () {
                        callback(reader.result);
                    }
                    if (xhr.response && xhr.response.type && xhr.response.type.startsWith('image/')) {
                        reader.readAsDataURL(xhr.response);
                    } else {
                        xhr.response.text().then(text => {
                            console.error(`Pollinations.ai respondió con un contenido inesperado. Estado: ${xhr.status} ${xhr.statusText}. Contenido:`, text);
                            mostrarMensajeImg4(`Error de Pollinations.ai: Contenido inesperado. Código: ${xhr.status}.`);
                        });
                    }
                } else {
                    console.error(`Error HTTP al cargar la imagen de Pollinations.ai: ${xhr.status} ${xhr.statusText}`);
                    mostrarMensajeImg4(`Error al generar imagen. Código HTTP: ${xhr.status}.`);
                }
            };
            xhr.onerror = function() {
                console.error("Error de red al cargar la imagen de Pollinations.ai. Posiblemente un problema de conexión o CORS.");
                mostrarMensajeImg4("Error de red al cargar la imagen. Verifica tu conexión o intenta más tarde.");
            };
            xhr.open('GET', url);
            xhr.responseType = 'blob';
            xhr.send();
        };

        /**
         * Generates algorithmic variations of an image continuously.
         * @param {string} mensaje - The base prompt for image generation.
         * @param {string} [modeloSeleccionado='flux'] - The model to use for generation.
         * @returns {{detener: function(): void}} An object with a `detener` method to stop continuous generation.
         */
        function generarVariacionesAlgoritmicas(mensaje, modeloSeleccionado = 'flux') {
            const galeria = document.getElementById("galeriaImagenes");
            let seed = 1;
            let generando = true;

            function generarSiguienteImagen() {
                if (!generando) return;

                const nuevaImagenURL = generarURLImagen(mensaje, seed, modeloSeleccionado);
                convertirURLADataURL(nuevaImagenURL, (dataURL) => {
                    const nuevaImagen = document.createElement("img");
                    nuevaImagen.src = dataURL;
                    nuevaImagen.setAttribute('data-url', dataURL);
                    nuevaImagen.addEventListener('click', seleccionarImagen);
                    galeria.appendChild(nuevaImagen);

                    if (galeria.children.length === 1) {
                        const imagenGenerada = document.getElementById("imagenGenerada");
                        imagenGenerada.src = dataURL;
                    }

                    seed++;
                    setTimeout(generarSiguienteImagen, 100);
                });
            }

            generarSiguienteImagen();
            return {
                detener: () => {
                    generando = false;
                }
            };
        };

        /**
         * Downloads an image from a given URL with a specified filename.
         * @param {string} url - The URL of the image to download.
         * @param {string} nombre - The filename for the downloaded image.
         */
        function descargarImagen(url, nombre) {
            const a = document.createElement('a');
            a.href = url;
            a.download = nombre;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        };

        /**
         * Downloads all currently selected images in the gallery as a ZIP file.
         */
        function descargarSeleccionadas() {
            const imagenesSeleccionadas = document.querySelectorAll('#image-4-container .seleccionada');
            if (imagenesSeleccionadas.length === 0) {
                mostrarMensajeImg4("No hay imágenes seleccionadas para descargar.");
                return;
            }

            const zip = new JSZip();
            let completedDownloads = 0;
            const totalImages = imagenesSeleccionadas.length;

            imagenesSeleccionadas.forEach((img, index) => {
                const url = img.getAttribute('data-url');
                const nombre = `imagen_seleccionada_${index + 1}.png`;

                fetch(url)
                    .then(response => response.blob())
                    .then(blob => {
                        zip.file(nombre, blob);
                        completedDownloads++;
                        if (completedDownloads === totalImages) {
                            zip.generateAsync({ type: "blob" })
                                .then(function (content) {
                                    const a = document.createElement('a');
                                    a.href = URL.createObjectURL(content);
                                    a.download = "imagenes_seleccionadas.zip";
                                    document.body.appendChild(a);
                                    a.click();
                                    document.body.removeChild(a);
                                    URL.revokeObjectURL(a.href);
                                });
                        }
                    })
                    .catch(error => {
                        console.error("Error al descargar la imagen seleccionada:", error);
                        mostrarMensajeImg4("Error al descargar una imagen seleccionada.");
                    });
            });
        };

        /**
         * Downloads all images in the gallery as a ZIP file.
         */
        function descargarGaleria() {
            const imagenes = galeriaImagenes.getElementsByTagName('img');
            if (imagenes.length === 0) {
                mostrarMensajeImg4("No hay imágenes en la galería para descargar.");
                return;
            }

            const zip = new JSZip();
            let completedDownloads = 0;
            const totalImages = imagenes.length;

            for (let i = 0; i < totalImages; i++) {
                const img = imagenes[i];
                const url = img.getAttribute('data-url');
                const nombre = `imagen_galeria_${i + 1}.png`;

                fetch(url)
                    .then(response => response.blob())
                    .then(blob => {
                        zip.file(nombre, blob);
                        completedDownloads++;
                        if (completedDownloads === totalImages) {
                            zip.generateAsync({ type: "blob" })
                                .then(function (content) {
                                    const a = document.createElement('a');
                                    a.href = URL.createObjectURL(content);
                                    a.download = "galeria_de_imagenes.zip";
                                    document.body.appendChild(a);
                                    a.click();
                                    document.body.removeChild(a);
                                    URL.revokeObjectURL(a.href);
                                });
                        }
                    })
                    .catch(error => {
                        console.error("Error al descargar la imagen de la galería:", error);
                        mostrarMensajeImg4("Error al descargar una imagen de la galería.");
                    });
            }
        };

        /**
         * Toggles the 'seleccionada' class on an image when clicked, for selection.
         * @param {Event} event - The click event.
         */
        function seleccionarImagen(event) {
            const img = event.target;
            img.classList.toggle('seleccionada');
        };

        /**
         * Displays a temporary message in the Image 4 interface.
         * @param {string} mensaje - The message to display.
         */
        function mostrarMensajeImg4(mensaje) {
            let messageDiv = document.getElementById('userMessage');
            if (messageDiv) {
                messageDiv.textContent = mensaje;
                messageDiv.style.opacity = '1';
                setTimeout(() => {
                    messageDiv.style.opacity = '0';
                }, 3000);
            } else {
                console.warn("Elemento 'userMessage' no encontrado en el DOM para Imagen 4.");
            }
        };

        /**
         * Shows the image configuration modal.
         */
        function showConfigModal() {
            modalAnchoInput.value = currentImageWidth;
            modalAltoInput.value = currentImageHeight;
            enhanceCheckbox.checked = isEnhanceEnabled;
            configModal.style.display = 'flex';
        }

        /**
         * Hides the image configuration modal.
         */
        function hideConfigModal() {
            configModal.style.display = 'none';
        }

        /**
         * Placeholder function for general schema generation (no longer directly used by new schema mode).
         */
        function generarEsquema() {
            console.log("La función 'generarEsquema' ha sido llamada.");
            displaySystemMessage("La función 'generarEsquema' se ha ejecutado. Aquí se generaría un esquema.");
        };

        // Map of diagram types to their Kroki/Mermaid syntax and generation instructions for Gemini.
        const diagramTypeMap = {
            "flujo": { krokiType: "mermaid", mermaidSyntax: "graph TD", promptKeyword: "un flujo o un grafo", geminiInstruction: "Mermaid, usando la sintaxis 'graph TD', para un flujo o un grafo. El diagrama debe resumir los puntos clave de manera muy detallada, sencilla y clara. **Proporciona solo el código Mermaid, sin explicaciones ni texto adicional, y sin envolverlo en bloques de Markdown. Para los nodos, usa el formato ID[TEXTO DEL NODO]. Asegúrate de que TEXTO DEL NODO sea texto plano, sin paréntesis, corchetes, comas, puntos y comas, ni caracteres especiales que puedan ser interpretados como sintaxis Mermaid. Cada línea del diagrama debe ser una declaración válida de nodo o conexión y debe terminar con un punto y coma (;) si no es la última línea del bloque.**", krokiContentType: 'text/plain' },
            "secuencia": { krokiType: "mermaid", mermaidSyntax: "sequenceDiagram", promptKeyword: "un diagrama de secuencia", geminiInstruction: "Mermaid, usando la sintaxis 'sequenceDiagram', para un diagrama de secuencia. Proporciona solo el código Mermaid, sin explicaciones ni texto adicional, y sin envolverlo en bloques de Markdown.", krokiContentType: 'text/plain' },
            "clases": { krokiType: "mermaid", mermaidSyntax: "classDiagram", promptKeyword: "un diagrama de clases", geminiInstruction: "Mermaid, usando la sintaxis 'classDiagram', para un diagrama de clases. Proporciona solo el código Mermaid, sin explicaciones ni texto adicional, y sin envolverlo en bloques de Markdown.", krokiContentType: 'text/plain' },
            "estados": { krokiType: "mermaid", mermaidSyntax: "stateDiagram-v2", promptKeyword: "un diagrama de estados", geminiInstruction: "Mermaid, usando la sintaxis 'stateDiagram-v2', para un diagrama de estados. Proporciona solo el código Mermaid, sin explicaciones ni texto adicional, y sin envolverlo en bloques de Markdown.", krokiContentType: 'text/plain' },
            "gantt": { krokiType: "mermaid", mermaidSyntax: "gantt", promptKeyword: "un diagrama de Gantt", geminiInstruction: "Mermaid, usando la sintaxis 'gantt', para un diagrama de Gantt. Proporciona solo el código Mermaid, sin explicaciones ni texto adicional, y sin envolverlo en bloques de Markdown.", krokiContentType: 'text/plain' },
            "tarta": { krokiType: "mermaid", mermaidSyntax: "pie", promptKeyword: "un diagrama de tarta", geminiInstruction: "Mermaid, usando la sintaxis 'pie', para un diagrama de tarta. Proporciona solo el código Mermaid, sin explicaciones ni texto adicional, y sin envolverlo en bloques de Markdown.", krokiContentType: 'text/plain' },
            "requisitos": { krokiType: "mermaid", mermaidSyntax: "requirementDiagram", promptKeyword: "un diagrama de requisitos", geminiInstruction: "Mermaid, usando la sintaxis 'requirementDiagram', para un diagrama de requisitos. Proporciona solo el código Mermaid, sin explicaciones ni texto adicional, y sin envolverlo en bloques de Markdown.", krokiContentType: 'text/plain' },
            "git": { krokiType: "mermaid", mermaidSyntax: "gitGraph", promptKeyword: "un diagrama de grafo de Git", geminiInstruction: "Mermaid, usando la sintaxis 'gitGraph', para un diagrama de grafo de Git. Proporciona solo el código Mermaid, sin explicaciones ni texto adicional, y sin envolverlo en bloques de Markdown.", krokiContentType: 'text/plain' },
            "viaje": { krokiType: "mermaid", mermaidSyntax: "journey", promptKeyword: "un diagrama de viaje de usuario", geminiInstruction: "Mermaid, usando la sintaxis 'journey', para un diagrama de viaje de usuario. Proporciona solo el código Mermaid, sin explicaciones ni texto adicional, y sin envolverlo en bloques de Markdown.", krokiContentType: 'text/plain' },
            "nube de palabras": { krokiType: "wordcloud", promptKeyword: "una nube de palabras", geminiInstruction: "una lista de palabras clave y su importancia (peso relativo) para una nube de palabras. La salida debe ser una lista de palabras, cada una seguida de dos puntos y un número (ej. 'palabra:10'), separadas por comas o saltos de línea. No incluyas ningún texto explicativo, solo la lista de palabras y pesos.", krokiContentType: 'text/plain' },
            "word cloud": { krokiType: "wordcloud", promptKeyword: "una nube de palabras", geminiInstruction: "una lista de palabras clave y su importancia (peso relativo) para una nube de palabras. La salida debe ser una lista de palabras, cada una seguida de dos puntos y un número (ej. 'palabra:10'), separadas por comas o saltos de línea. No incluyas ningún texto explicativo, solo la lista de palabras y pesos.", krokiContentType: 'text/plain' },
            "blockdiag": { krokiType: "blockdiag", promptKeyword: "un diagrama BlockDiag (de bloques)", geminiInstruction: "BlockDiag para un diagrama de bloques. Proporciona el código BlockDiag sin explicaciones ni texto adicional, y sin envolverlo en bloques de Markdown.", krokiContentType: 'text/plain' },
            "bpmn": { krokiType: "bpmn", promptKeyword: "un diagrama BPMN", geminiInstruction: "BPMN para un diagrama de proceso de negocio. Proporciona el código BPMN sin explicaciones ni texto adicional, y sin envolverlo en bloques de Markdown.", krokiContentType: 'text/plain' },
            "bytefield": { krokiType: "bytefield", promptKeyword: "un diagrama Bytefield (de campo de bytes)", geminiInstruction: "Bytefield para un diagrama de campo de bytes. Proporciona el código Bytefield sin explicaciones ni texto adicional, y sin envolverlo en bloques de Markdown.", krokiContentType: 'text/plain' },
            "seqdiag": { krokiType: "seqdiag", promptKeyword: "un diagrama SeqDiag (de secuencia)", geminiInstruction: "SeqDiag para un diagrama de secuencia. Proporciona el código SeqDiag sin explicaciones ni texto adicional, y sin envolverlo en bloques de Markdown.", krokiContentType: 'text/plain' },
            "actdiag": { krokiType: "actdiag", promptKeyword: "un diagrama ActDiag (de actividad)", geminiInstruction: "ActDiag para un diagrama de actividad. Proporciona el código ActDiag sin explicaciones ni texto adicional, y sin envolverlo en bloques de Markdown.", krokiContentType: 'text/plain' },
            "nwdiag": { krokiType: "nwdiag", promptKeyword: "un diagrama NwDiag (de red)", geminiInstruction: "NwDiag para un diagrama de red. Proporciona el código NwDiag sin explicaciones ni texto adicional, y sin envolverlo en bloques de Markdown.", krokiContentType: 'text/plain' },
            "packetdiag": { krokiType: "packetdiag", promptKeyword: "un diagrama PacketDiag (de paquetes)", geminiInstruction: "PacketDiag para un diagrama de paquetes. Proporciona el código PacketDiag sin explicaciones ni texto adicional, y sin envolverlo en bloques de Markdown.", krokiContentType: 'text/plain' },
            "rackdiag": { krokiType: "rackdiag", promptKeyword: "un diagrama RackDiag (de rack)", geminiInstruction: "RackDiag para un diagrama de rack. Proporciona el código RackDiag sin explicaciones ni texto adicional, y sin envolverlo en bloques de Markdown.", krokiContentType: 'text/plain' },
            "c4plantuml": { krokiType: "c4plantuml", promptKeyword: "un diagrama C4 con PlantUML", geminiInstruction: "C4 PlantUML para un diagrama C4. Proporciona el código C4 PlantUML sin explicaciones ni texto adicional, y sin envolverlo en bloques de Markdown.", krokiContentType: 'text/plain' },
            "d2": { krokiType: "d2", promptKeyword: "un diagrama D2", geminiInstruction: "D2 para un diagrama D2. Proporciona el código D2 sin explicaciones ni texto adicional, y sin envolverlo en bloques de Markdown.", krokiContentType: 'text/plain' },
            "dbml": { krokiType: "dbml", promptKeyword: "un diagrama DBML", geminiInstruction: "DBML para un diagrama de base de datos. Proporciona el código DBML sin explicaciones ni texto adicional, y sin envolverlo en bloques de Markdown.", krokiContentType: 'text/plain' },
            "ditaa": { krokiType: "ditaa", promptKeyword: "un diagrama Ditaa", geminiInstruction: "Ditaa para un diagrama Ditaa. Proporciona el código Ditaa sin explicaciones ni texto adicional, y sin envolverlo en bloques de Markdown.", krokiContentType: 'text/plain' },
            "erd": { krokiType: "erd", promptKeyword: "un diagrama ERD", geminiInstruction: "Erd para un diagrama de entidad-relación. Proporciona el código Erd sin explicaciones ni texto adicional, y sin envolverlo en bloques de Markdown.", krokiContentType: 'text/plain' },
            "excalidraw": { krokiType: "excalidraw", promptKeyword: "un diagrama Excalidraw", geminiInstruction: "Excalidraw para un diagrama tipo boceto. Proporciona el código Excalidraw sin explicaciones ni texto adicional, y sin envolverlo en bloques de Markdown.", krokiContentType: 'text/plain' },
            "graphviz": { krokiType: "graphviz", promptKeyword: "un diagrama GraphViz", geminiInstruction: "GraphViz para un diagrama de grafo. Proporciona el código GraphViz sin explicaciones ni texto adicional, y sin envolverlo en bloques de Markdown.", krokiContentType: 'text/plain' },
            "nomnoml": { krokiType: "nomnoml", promptKeyword: "un diagrama Nomnoml", geminiInstruction: "Nomnoml para un diagrama Nomnoml. Proporciona el código Nomnoml sin explicaciones ni texto adicional, y sin envolverlo en bloques de Markdown.", krokiContentType: 'text/plain' },
            "pikchr": { krokiType: "pikchr", promptKeyword: "un diagrama Pikchr", geminiInstruction: "Pikchr para un diagrama Pikchr. Proporciona el código Pikchr sin explicaciones ni texto adicional, y sin envolverlo en bloques de Markdown.", krokiContentType: 'text/plain' },
            "plantuml": { krokiType: "plantuml", promptKeyword: "un diagrama PlantUML", geminiInstruction: "PlantUML para un diagrama PlantUML. Proporciona el código PlantUML sin explicaciones ni texto adicional, y sin envolverlo en bloques de Markdown.", krokiContentType: 'text/plain' },
            "structurizr": { krokiType: "structurizr", promptKeyword: "un diagrama Structurizr", geminiInstruction: "Structurizr para un diagrama Structurizr. Proporciona el código Structurizr sin explicaciones ni texto adicional, y sin envolverlo en bloques de Markdown.", krokiContentType: 'text/plain' },
            "svgbob": { krokiType: "svgbob", promptKeyword: "un diagrama Svgbob", geminiInstruction: "Svgbob para un diagrama ASCII. Proporciona el código Svgbob sin explicaciones ni texto adicional, y sin envolverlo en bloques de Markdown.", krokiContentType: 'text/plain' },
            "symbolator": { krokiType: "symbolator", promptKeyword: "un diagrama Symbolator", geminiInstruction: "Symbolator para un diagrama Symbolator. Proporciona el código Symbolator sin explicaciones ni texto adicional, y sin envolverlo en bloques de Markdown.", krokiContentType: 'text/plain' },
            "tikz": { krokiType: "tikz", promptKeyword: "un diagrama TikZ", geminiInstruction: "TikZ para un diagrama TikZ. Proporciona el código TikZ sin explicaciones ni texto adicional, y sin envolverlo en bloques de Markdown.", krokiContentType: 'text/plain' },
            "umlet": { krokiType: "umlet", promptKeyword: "un diagrama UMlet", geminiInstruction: "UMlet para un diagrama UMlet. Proporciona el código UMlet sin explicaciones ni texto adicional, y sin envolverlo en bloques de Markdown.", krokiContentType: 'text/plain' },
            "vega": { krokiType: "vega", promptKeyword: "un diagrama Vega", geminiInstruction: "Vega para un diagrama Vega. Proporciona el código Vega JSON sin explicaciones ni texto adicional, y sin envolverlo en bloques de Markdown.", krokiContentType: 'application/json' },
            "vega-lite": { krokiType: "vegalite", promptKeyword: "un diagrama Vega-Lite", geminiInstruction: "Vega-Lite para un diagrama Vega-Lite. Proporciona el código Vega-Lite JSON sin explicaciones ni texto adicional, y sin envolverlo en bloques de Markdown.", krokiContentType: 'application/json' },
            "wavedrom": { krokiType: "wavedrom", promptKeyword: "un diagrama WaveDrom", geminiInstruction: "WaveDrom para un diagrama de forma de onda. Proporciona el código WaveDrom JSON sin explicaciones ni texto adicional, y sin envolverlo en bloques de Markdown.", krokiContentType: 'application/json' },
            "wireviz": { krokiType: "wireviz", promptKeyword: "un diagrama WireViz", geminiInstruction: "WireViz para un diagrama de cableado. Proporciona el código WireViz YAML sin explicaciones ni texto adicional, y sin envolverlo en bloques de Markdown.", krokiContentType: 'application/x-yaml' }
        };

        /**
         * Generates an interactive schema (diagram) using Gemini and Kroki APIs based on the user's message.
         * @param {string} message - The user's input message describing the desired schema.
         */
        async function generarEsquemaInteractivoHTML(message) {
            let topic = message;
            let krokiDiagramType = "mermaid";
            let mermaidSyntax = "graph TD";
            let promptKeyword = "un flujo o un grafo";
            let geminiInstruction = diagramTypeMap["flujo"].geminiInstruction;
            let krokiContentType = 'text/plain';
            const MAX_SCHEMA_RETRIES = 3; // Reduced retries for quicker feedback

            let foundType = false;
            for (const [key, value] of Object.entries(diagramTypeMap)) {
                // More flexible matching: "diagrama de [tipo] sobre [tema]", or just "[tipo] sobre [tema]"
                const typeRegex = new RegExp(`(?:diagrama de\\s+)?(${key.replace(/-/g, '\\s*-?')})\\s+sobre\\s+(.+)`, 'i');
                const match = message.match(typeRegex);

                if (match) {
                    krokiDiagramType = value.krokiType;
                    if (value.mermaidSyntax) {
                        mermaidSyntax = value.mermaidSyntax;
                    }
                    promptKeyword = value.promptKeyword;
                    geminiInstruction = value.geminiInstruction;
                    krokiContentType = value.krokiContentType;
                    topic = match[2].trim();
                    foundType = true;
                    break;
                }
            }

            if (!foundType) {
                // If no specific diagram type is mentioned, assume a default Mermaid flow chart
                displaySystemMessage("Tipo de diagrama no especificado o reconocido. Generando un diagrama de flujo (Mermaid) por defecto para el tema.");
                topic = message; // Use the whole message as topic
            }

            displaySystemMessage(`Generando ${promptKeyword} para: "${topic}"...`);

            let geminiPromptForDiagram;
            if (krokiDiagramType === "wordcloud") {
                geminiPromptForDiagram = `Genera ${geminiInstruction.replace('una lista de palabras clave y su importancia (peso relativo) para una nube de palabras. La salida debe ser una lista de palabras, cada una seguida de dos puntos y un número (ej. \'palabra:10\'), separadas por comas o saltos de línea. No incluyas ningún texto explicativo, solo la lista de palabras y pesos.', '')} una lista de palabras clave y su importancia (peso relativo) para una nube de palabras sobre "${topic}". La salida debe ser una lista de palabras, cada una seguida de dos puntos y un número (ej. 'palabra:10'), separadas por comas o saltos de línea. No incluyas ningún texto explicativo, solo la lista de palabras y pesos.`;
            } else if (krokiDiagramType === "mermaid") {
                geminiPromptForDiagram = `Genera el código Mermaid ${mermaidSyntax ? `con la sintaxis '${mermaidSyntax}'` : ''} para ${promptKeyword} sobre "${topic}". **Proporciona solo el código Mermaid, sin explicaciones ni texto adicional, y sin envolverlo en bloques de Markdown. Para los nodos, usa el formato ID[TEXTO_DEL_NODO]. Asegúrate de que TEXTO_DEL_NODO sea texto plano, sin paréntesis, corchetes anidados, comas, puntos y comas, ni caracteres especiales como /, \\, #, &, *, +, -, {}, [], <>, \"\", '', que puedan ser interpretados como sintaxis Mermaid o HTML. Cada línea del diagrama debe ser una declaración válida de nodo o conexión y debe terminar con un punto y coma (;) si no es la última línea del bloque.**`;
            } else {
                geminiPromptForDiagram = `Genera el código ${krokiDiagramType} para ${promptKeyword} sobre "${topic}". Proporciona solo el código, sin explicaciones ni texto adicional, y sin envolverlo en bloques de Markdown.`
            }

            let finalGeminiPromptForDiagram = geminiPromptForDiagram;
            if (contextUrls.length > 0) {
                const urlsForPrompt = contextUrls.join('\n');
                finalGeminiPromptForDiagram = `Considera las siguientes URLs como contexto: ${urlsForPrompt}\n\n${geminiPromptForDiagram}`;
            }

            const geminiPayload = {
                contents: [{ role: 'user', parts: [{ text: finalGeminiPromptForDiagram }] }],
                generationConfig: {
                    temperature: 0.7,
                    topP: 0.95,
                    topK: 40,
                    maxOutputTokens: 2048,
                },
                tools: contextUrls.length > 0 ? [{ urlContext: {} }] : [],
            };

            let diagramSourceCode = '';
            let geminiApiSuccess = false;

            for (let i = 0; i <= MAX_SCHEMA_RETRIES; i++) {
                try {
                    console.log(`Intento ${i + 1} de generación de esquema. Prompt a Gemini:`, JSON.stringify(geminiPayload));
                    const geminiResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(geminiPayload)
                    });

                    if (!geminiResponse.ok) {
                        const errorText = await geminiResponse.text();
                        console.error(`Intento ${i + 1} fallido de API de Gemini (Generación de código de diagrama):`, geminiResponse.status, geminiResponse.statusText, errorText);
                        if (i < MAX_SCHEMA_RETRIES) {
                            displaySystemMessage(`Error en el intento ${i + 1} de generación de esquema. Reintentando...`);
                            continue;
                        } else {
                            throw new Error(`Error de API (Generación de código de diagrama): ${geminiResponse.status} ${geminiResponse.statusText} - ${errorText}`);
                        }
                    }

                    const geminiData = await geminiResponse.json();
                    console.log(`Raw Gemini Diagram Code Data (Intento ${i + 1}):`, JSON.stringify(geminiData, null, 2));

                    if (geminiData.candidates && geminiData.candidates.length > 0 &&
                        geminiData.candidates[0].content && geminiData.candidates[0].content.parts &&
                        geminiData.candidates[0].content.parts.length > 0) {
                        diagramSourceCode = geminiData.candidates[0].content.parts[0].text.trim();
                        console.log(`Extracted Gemini Diagram Source Code (Intento ${i + 1}):`, diagramSourceCode);
                        geminiApiSuccess = true;
                        break;
                    } else {
                        console.warn(`Intento ${i + 1} fallido: No se encontraron candidatos válidos en la respuesta de Gemini.`);
                        if (i < MAX_SCHEMA_RETRIES) {
                            displaySystemMessage(`Respuesta vacía de Gemini en el intento ${i + 1}. Reintentando...`);
                            continue;
                        } else {
                            throw new Error('Gemini no pudo generar el código del diagrama después de múltiples intentos.');
                        }
                    }
                } catch (error) {
                    console.error(`Intento ${i + 1} fallido con excepción:`, error);
                    if (i < MAX_SCHEMA_RETRIES) {
                        displaySystemMessage(`Excepción en el intento ${i + 1} de generación de esquema. Reintentando...`);
                        continue;
                    } else {
                        displaySystemMessage('Error: No se pudo generar el código del esquema después de múltiples intentos. Nuestro servidor falló o el modelo no respondió como se esperaba.');
                        messageInput.value = message;
                        return;
                    }
                }
            }


            if (!geminiApiSuccess) {
                displaySystemMessage('Error: No se pudo generar el código del esquema después de múltiples intentos. Nuestro servidor falló o el modelo no respondió como se esperaba.');
                messageInput.value = message;
                return;
            }

            // Clean up any markdown code blocks if Gemini accidentally added them
            if (diagramSourceCode.startsWith('```') && diagramSourceCode.endsWith('```')) {
                const lines = diagramSourceCode.split('\n');
                if (lines.length > 2 && lines[0].startsWith('```') && lines[lines.length - 1] === '```') {
                    diagramSourceCode = lines.slice(1, -1).join('\n').trim();
                    // Also remove the language specifier if present (e.g., 'mermaid')
                    const firstLineAfterTicks = lines[1].trim();
                    if (firstLineAfterTicks.match(/^[a-zA-Z-]+$/) && firstLineAfterTicks.toLowerCase() === krokiDiagramType.toLowerCase()) {
                        diagramSourceCode = lines.slice(2, -1).join('\n').trim();
                    }
                }
            }

            try {
                const krokiUrl = `https://kroki.io/${krokiDiagramType}/svg`;
                console.log("Enviando código a Kroki.io:", diagramSourceCode);
                const krokiResponse = await fetch(krokiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': krokiContentType },
                    body: diagramSourceCode
                });

                if (!krokiResponse.ok) {
                    const errorText = await krokiResponse.text();
                    console.error('API response not OK (Generación de diagrama de Kroki):', krokiResponse.status, krokiResponse.statusText, errorText);
                    displaySystemMessage(`Error al generar el diagrama con Kroki.io: ${krokiResponse.status} ${krokiResponse.statusText}. Esto podría deberse a un formato incorrecto del código del diagrama. Por favor, revisa la consola para más detalles.`);
                    // Display the problematic code for the user to see/debug
                    let responseHtml = showdownConverter.makeHtml(`El código de diagrama generado por la IA es el siguiente (puede que contenga errores):\n\n\`\`\`${krokiDiagramType}\n${diagramSourceCode}\n\`\`\``);
                    const geminiMessageDiv = document.createElement('div');
                    geminiMessageDiv.className = 'gemini-message';
                    geminiMessageDiv.innerHTML = responseHtml;
                    chatContainer.appendChild(geminiMessageDiv);
                    chatContainer.scrollTop = chatContainer.scrollHeight;
                    renderMath();
                    messageInput.value = message;
                    return; // Stop here if Kroki fails
                }

                const diagramSvg = await krokiResponse.text();
                console.log("SVG del diagrama generado por Kroki:", diagramSvg.substring(0, 500) + '...');

                htmlPreviewTextarea.value = diagramSvg;
                const dataUrl = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(diagramSvg)}`; // Use image/svg+xml for SVG data URL
                dataUrlTextSpan.textContent = dataUrl; // NEW: Set the text content of the span
                const iframeDoc = htmlPreviewIframe.contentWindow.document;
                iframeDoc.open();
                iframeDoc.write(diagramSvg);
                iframeDoc.close();

                showTab('tab-content-html-preview');
                archivoMenu.classList.add('active');

                let chatDisplayMessage = `¡${promptKeyword.charAt(0).toUpperCase() + promptKeyword.slice(1)} para "${topic}" generado con éxito! Puedes verlo en la pestaña 'Previsualizar HTML' del menú 'MAS'.`;

                let responseHtml = showdownConverter.makeHtml(chatDisplayMessage);
                responseHtml = responseHtml.replace(/(-b ± √(b² - 4ac)) \/ 2a/g, '<span class="katex">\\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}</span>');
                responseHtml = responseHtml.replace(/x\^2/g, '<span class="katex">x^2</span>');
                responseHtml = responseHtml.replace(/a\/b/g, '<span class="katex">\\frac{a}{b}</span>');
                responseHtml = responseHtml.replace(/\\sqrt\{(\w+)\}/g, '<span class="katex">\\sqrt{$1}</span>');
                responseHtml = responseHtml.replace(/\\sqrt\{(b\^2 - 4ac)\}/g, '<span class="katex">\\sqrt{b^2 - 4ac}</span>');
                responseHtml = responseHtml.replace(/(\\frac\{\w+\}\{\w+\})/g, '<span class="katex">$1</span>');
                responseHtml = responseHtml.replace(/<pre><code[^>]*>([\s\S]*?)<\/code><\/pre>/g, (match, code) => {
                    const highlightedCode = highlightCode(code.trim());
                    return `<pre><code class="code-block">${highlightedCode}</code></pre>`;
                });

                const geminiMessageDiv = document.createElement('div');
                geminiMessageDiv.className = 'gemini-message';
                geminiMessageDiv.innerHTML = responseHtml;
                chatContainer.appendChild(geminiMessageDiv);
                chatContainer.scrollTop = chatContainer.scrollHeight;

                history.push({ role: 'model', parts: [{ text: chatDisplayMessage }] });

                fileDataArray = [];
                fileInput.value = '';
                renderAllUploadedLists();

            } catch (error) {
                console.error('Error al generar diagrama interactivo con Kroki o al mostrarlo:', error);
                displaySystemMessage('Error: No se pudo generar el diagrama interactivo o hubo un problema al mostrarlo. Inténtalo de nuevo. Asegúrate de que el tema sea claro y que la sintaxis de tu solicitud sea correcta.');
                messageInput.value = message;
            }
        };

        // Helper function to recursively build the HTML for the schema (no longer used for Kroki diagrams directly)
        function buildInteractiveSchemaHtml(data) {
            let html = '';
            html += `
        <div style="text-align: center; margin-top: 20px;">
            <h3>Diagrama Generado por Kroki</h3>
            </div>
    `;
            return html;
        };


        // --- Start of existing 'esquemas' function (kept for compatibility) ---
        function esquemas() {
            console.log("La función 'esquemas' ha sido llamada.");
            displaySystemMessage("La función 'esquemas' se ha ejecutado. Esta es una función genérica para esquemas. Para generar un diagrama interactivo, activa el 'Modo Esquema' y proporciona un tema.");
        };
        // --- End of existing 'esquemas' function ---

        /**
         * Initializes event listeners and sets up the Image 4 application mode.
         * Ensures listeners are added only once.
         */
        function initializeImage4App() {
            // Only initialize listeners if they haven't been added yet
            if (!generarImagenBtn.dataset.listenerAdded) {
                generarImagenBtn.addEventListener("click", () => {
                    const mensaje = mensajeInputImg4.value.trim();
                    const modeloSeleccionado = modeloSelector.value;
                    if (mensaje) {
                        currentSeed = 0;
                        const nuevaImagenURL = generarURLImagen(mensaje, currentSeed, modeloSeleccionado);
                        convertirURLADataURL(nuevaImagenURL, (dataURL) => {
                            imagenGenerada.src = dataURL;
                            const nuevaImagen = document.createElement("img");
                            nuevaImagen.src = dataURL;
                            nuevaImagen.setAttribute('data-url', dataURL);
                            nuevaImagen.addEventListener('click', seleccionarImagen);
                            galeriaImagenes.appendChild(nuevaImagen);
                        });
                    } else {
                        mostrarMensajeImg4("Por favor, introduce un mensaje antes de generar la imagen.");
                    }
                });
                generarImagenBtn.dataset.listenerAdded = true;
            }

            if (!variarImagenBtn.dataset.listenerAdded) {
                variarImagenBtn.addEventListener("click", () => {
                    const mensaje = mensajeInputImg4.value.trim();
                    const modeloSeleccionado = modeloSelector.value;
                    if (mensaje) {
                        currentSeed = generarNumeroAleatorio();
                        const nuevaImagenURL = generarURLImagen(mensaje, currentSeed, modeloSeleccionado);
                        convertirURLADataURL(nuevaImagenURL, (dataURL) => {
                            imagenGenerada.src = dataURL;
                            const nuevaImagen = document.createElement("img");
                            nuevaImagen.src = dataURL;
                            nuevaImagen.setAttribute('data-url', dataURL);
                            nuevaImagen.addEventListener('click', seleccionarImagen);
                            galeriaImagenes.appendChild(nuevaImagen);
                        });
                    } else {
                        mostrarMensajeImg4("Por favor, introduce un mensaje antes de generar la imagen.");
                    }
                });
                variarImagenBtn.dataset.listenerAdded = true;
            }

            if (!variacionAlgoritmicaBtn.dataset.listenerAdded) {
                variacionAlgoritmicaBtn.addEventListener("click", () => {
                    const mensaje = mensajeInputImg4.value.trim();
                    const modeloSeleccionado = modeloSelector.value;
                    if (mensaje) {
                        generacionContinua = generarVariacionesAlgoritmicas(mensaje, modeloSeleccionado);
                        variacionAlgoritmicaBtn.style.display = "none";
                        pararVariacionBtn.style.display = "inline-block";
                        galeriaImagenes.style.display = "flex";
                        verBibliotecaBtn.style.display = "none";
                        ocultarBibliotecaBtn.style.display = "inline-block";
                    } else {
                        mostrarMensajeImg4("Por favor, introduce un mensaje antes de generar la imagen.");
                    }
                });
                variacionAlgoritmicaBtn.dataset.listenerAdded = true;
            }

            if (!pararVariacionBtn.dataset.listenerAdded) {
                pararVariacionBtn.addEventListener("click", () => {
                    if (generacionContinua) {
                        generacionContinua.detener();
                    }
                    pararVariacionBtn.style.display = "none";
                    variacionAlgoritmicaBtn.style.display = "inline-block";
                });
                pararVariacionBtn.dataset.listenerAdded = true;
            }

            if (!verBibliotecaBtn.dataset.listenerAdded) {
                verBibliotecaBtn.addEventListener("click", () => {
                    galeriaImagenes.style.display = "flex";
                    verBibliotecaBtn.style.display = "none";
                    ocultarBibliotecaBtn.style.display = "inline-block";
                });
                verBibliotecaBtn.dataset.listenerAdded = true;
            }

            if (!ocultarBibliotecaBtn.dataset.listenerAdded) {
                ocultarBibliotecaBtn.addEventListener("click", () => {
                    galeriaImagenes.style.display = "none";
                    verBibliotecaBtn.style.display = "inline-block";
                    ocultarBibliotecaBtn.style.display = "none";
                });
                ocultarBibliotecaBtn.dataset.listenerAdded = true;
            }

            if (!descargarImagenBtn.dataset.listenerAdded) {
                descargarImagenBtn.addEventListener("click", () => {
                    descargarImagen(imagenGenerada.src, 'imagen_generada.png');
                });
                descargarImagenBtn.dataset.listenerAdded = true;
            }

            if (!descargarGaleriaBtn.dataset.listenerAdded) {
                descargarGaleriaBtn.addEventListener("click", () => {
                    descargarGaleria();
                });
                descargarGaleriaBtn.dataset.listenerAdded = true;
            }

            if (!descargarSeleccionadasBtn.dataset.listenerAdded) {
                descargarSeleccionadasBtn.addEventListener("click", () => {
                    descargarSeleccionadas();
                });
                descargarSeleccionadasBtn.dataset.listenerAdded = true;
            }

            if (!configurarDimensionesBtn.dataset.listenerAdded) {
                configurarDimensionesBtn.addEventListener("click", showConfigModal);
                configurarDimensionesBtn.dataset.listenerAdded = true;
            }

            if (!modalAceptarBtn.dataset.listenerAdded) {
                modalAceptarBtn.addEventListener("click", () => {
                    const newWidth = parseInt(modalAnchoInput.value);
                    const newHeight = parseInt(modalAltoInput.value);
                    const newEnhanceState = enhanceCheckbox.checked;

                    if (newWidth > 0 && newHeight > 0) {
                        currentImageWidth = newWidth;
                        currentImageHeight = newHeight;
                        isEnhanceEnabled = newEnhanceState;
                        mostrarMensajeImg4(`Dimensiones actualizadas a ${currentImageWidth}x${currentImageHeight}. Mejora: ${isEnhanceEnabled ? 'activada' : 'desactivada'}.`);
                    } else {
                        mostrarMensajeImg4("Ancho y alto deben ser números positivos.");
                    }
                    hideConfigModal();
                });
                modalAceptarBtn.dataset.listenerAdded = true;
            }

            if (!modalCancelarBtn.dataset.listenerAdded) {
                modalCancelarBtn.addEventListener("click", hideConfigModal);
                modalCancelarBtn.dataset.listenerAdded = true;
            }


            if (!backToChatButton.dataset.listenerAdded) {
                backToChatButton.addEventListener("click", () => {
                    showChatMode();
                });
                backToChatButton.dataset.listenerAdded = true;
            }

            if (!imagenGenerada.src || imagenGenerada.src.includes("placehold.co")) {
                convertirURLADataURL(generarURLImagen("Imagen 4", currentSeed, modeloSelector.value), (dataURL) => {
                    imagenGenerada.src = dataURL;
                });
            }
        };

        // NEW URL CONTEXT FUNCTIONS
        /**
         * Renders the list of URLs currently in the `contextUrls` array.
         */
        function renderUrlList() {
            urlList.innerHTML = '';
            contextUrls.forEach((url, index) => {
                const listItem = document.createElement('li');
                listItem.classList.add('url-item');
                listItem.innerHTML = `
                    <a href="${url}" target="_blank">${url}</a>
                    <button class="delete-url-button" data-index="${index}">Eliminar</button>
                `;
                urlList.appendChild(listItem);
            });
        }

        /**
         * Renders the URL context metadata received from Gemini API.
         * @param {Array<Object>} urlMetadata - Array of URL metadata objects from Gemini.
         */
        function renderUrlContextMetadata(urlMetadata) {
            retrievedUrlList.innerHTML = ''; // Clear previous status
            if (urlMetadata && urlMetadata.length > 0) {
                urlMetadata.forEach(meta => {
                    const listItem = document.createElement('li');
                    let statusClass = '';
                    let statusText = '';

                    // Assign class based on status
                    if (meta.url_retrieval_status && meta.url_retrieval_status.includes('SUCCESS')) {
                        statusClass = 'url-retrieval-status-success';
                        statusText = ' (Éxito)';
                    } else if (meta.url_retrieval_status && meta.url_retrieval_status.includes('FAILURE')) {
                        statusClass = 'url-retrieval-status-failure';
                        statusText = ' (Fallo)';
                    } else {
                        statusClass = 'url-retrieval-status-unspecified';
                        statusText = ' (Estado Desconocido)';
                    }

                    listItem.className = statusClass;
                    listItem.innerHTML = `<span>${meta.retrieved_url}${statusText}</span>`;
                    retrievedUrlList.appendChild(listItem);
                });
                // Ensure the menu is open and on the correct tab to show this feedback
                archivoMenu.classList.add('active');
                showTab('tab-content-files'); // Keep it on the files tab which now includes URL context
            } else {
                const listItem = document.createElement('li');
                listItem.textContent = 'No se recuperó metadatos de URL o no se procesaron URLs en la última respuesta.';
                retrievedUrlList.appendChild(listItem);
            }
        }


        // Event listener for adding a URL
        addUrlButton.addEventListener('click', () => {
            const url = urlInput.value.trim();
            if (url) {
                try {
                    new URL(url);
                    if (!contextUrls.includes(url)) {
                        contextUrls.push(url);
                        renderUrlList();
                        urlInput.value = '';
                        displaySystemMessage(`URL "${url}" añadida al contexto del chat.`);
                    } else {
                        displaySystemMessage(`La URL "${url}" ya está en la lista.`);
                    }
                } catch (e) {
                    displaySystemMessage(`Por favor, introduce una URL válida.`);
                }
            } else {
                displaySystemMessage('Por favor, introduce una URL.');
            }
        });

        // Event listener for deleting a URL
        urlList.addEventListener('click', (event) => {
            if (event.target.classList.contains('delete-url-button')) {
                const index = parseInt(event.target.dataset.index);
                if (index !== -1 && index < contextUrls.length) {
                    const deletedUrl = contextUrls.splice(index, 1)[0];
                    renderUrlList();
                    displaySystemMessage(`URL "${deletedUrl}" eliminada del contexto.`);
                }
            }
        });
        
        // MODIFIED: Event listener for the thinking mode toggle (new ID)
        thinkingModeToggle.addEventListener('change', updateThinkingUIState);
        // MODIFIED: Event listener for the set thinking budget toggle (new ID)
        setThinkingBudgetToggle.addEventListener('change', updateThinkingUIState);
        // MODIFIED: Event listener for the thinking budget slider (new ID)
        thinkingBudgetSlider.addEventListener('input', updateThinkingUIState);

        // Initial UI state update for thinking controls
        function updateThinkingUIState() {
            // Enable/disable the set thinking budget toggle and the slider container
            if (thinkingModeToggle.checked) {
                setThinkingBudgetToggle.disabled = false;
                budgetSliderContainer.classList.remove('opacity-50', 'pointer-events-none');
            } else {
                setThinkingBudgetToggle.checked = false; // Deactivate if thinking mode is off
                setThinkingBudgetToggle.disabled = true;
                budgetSliderContainer.classList.add('opacity-50', 'pointer-events-none');
            }

            // Enable/disable the slider itself
            if (setThinkingBudgetToggle.checked && thinkingModeToggle.checked) {
                thinkingBudgetSlider.disabled = false;
                thinkingBudgetValue.classList.remove('opacity-50');
            } else {
                thinkingBudgetSlider.disabled = true;
                thinkingBudgetValue.classList.add('opacity-50');
            }

            // Update the displayed value of the slider
            thinkingBudgetValue.textContent = thinkingBudgetSlider.value;
        }


        window.onload = function () {
            // MODIFIED: Enable table conversion in showdown
            showdownConverter = new showdown.Converter({ tables: true });
            renderMath();
            chatContainer.style.fontSize = fontSizeSelector.value + 'px';
            updateInputPlaceholder();
            showChatMode();
            renderAllUploadedLists(); // Call this to render both files and URLs
            
            // Set default font family for the chat container (now hardcoded as the input was removed)
            chatContainer.style.fontFamily = "'Segoe UI', Tahoma, Geneva, Verdana, sans-serif";
            // No longer need to set fontFamilyInput.value as the input itself is removed.

            // Call updateThinkingUIState on load to set initial state correctly
            updateThinkingUIState();
        };
    </script>
</body>

</html>