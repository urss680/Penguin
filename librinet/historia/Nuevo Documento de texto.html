<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LibrillaiA</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        #chat-container {
            width: 90%;
            max-width: 800px;
            margin: 20px auto 10px auto;
            border: 1px solid #ddd;
            background-color: white;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            height: 500px;
            overflow-y: auto;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            border-radius: 8px;
        }

        .user-message,
        .gemini-message {
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 8px;
            word-wrap: break-word;
            max-width: 80%;
        }

        .user-message {
            background-color: #e3f2fd;
            text-align: right;
            align-self: flex-end;
            color: #1a73e8; /* A shade of blue */
        }

        .gemini-message {
            background-color: #f0f0f0;
            text-align: left;
            color: #333;
            align-self: flex-start;
        }

        #input-container {
            width: 90%;
            max-width: 800px;
            margin: 10px auto;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap; /* Allow items to wrap */
        }

        #message-input {
            flex-grow: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            min-width: 150px; /* Ensure input doesn't get too small */
        }

        #send-button,
        #read-button,
        #download-pdf-button,
        #archivos-button,
        #report-button,
        #html-mode-button,
        #live-mode-button, /* Added new button to style */
        #send-live-message-button { /* New button style */
            padding: 10px 15px;
            background-color: #4caf50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            white-space: nowrap; /* Prevent button text from wrapping */
        }

        #send-button:hover,
        #read-button:hover,
        #download-pdf-button:hover,
        #archivos-button:hover,
        #report-button:hover,
        #html-mode-button:hover,
        #live-mode-button:hover, /* Added new button to style */
        #send-live-message-button:hover { /* New button style */
            background-color: #45a049;
        }

        #file-input {
            display: none;
        }

        label[for="file-input"] {
            background-color: #007bff;
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            white-space: nowrap;
        }

        label[for="file-input"]:hover {
            background-color: #0056b3;
        }

        #font-size {
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #ddd;
            min-width: 60px; /* Ensure select box has a minimum width */
        }

        code {
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
            white-space: pre-wrap;
            display: block;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        /* Styles for the side file menu */
        #archivo-menu {
            position: fixed;
            top: 0;
            right: -300px;
            width: 300px;
            height: 100%;
            background-color: #f8f8f8;
            border-left: 1px solid #ccc;
            transition: right 0.5s;
            padding: 20px;
            box-sizing: border-box;
            z-index: 1000;
            box-shadow: -2px 0 5px rgba(0, 0, 0, 0.1);
            overflow-y: auto; /* Enable scrolling for content */
        }

        #archivo-menu.active {
            right: 0;
        }

        #archivo-menu h2 {
            margin-top: 0;
            color: #333;
        }

        #close-menu-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 1.8em;
            cursor: pointer;
            color: #555;
        }

        #close-menu-button:hover {
            color: #000;
        }

        .tab-buttons {
            display: flex;
            margin-bottom: 15px;
            border-bottom: 1px solid #ddd;
        }

        .tab-buttons button {
            flex: 1;
            padding: 10px 15px;
            border: none;
            background-color: #e0e0e0;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.3s;
            border-radius: 5px 5px 0 0;
            margin-right: 2px;
        }

        .tab-buttons button:last-child {
            margin-right: 0;
        }

        .tab-buttons button.active-tab {
            background-color: #007bff;
            color: white;
            font-weight: bold;
        }

        .tab-buttons button:hover:not(.active-tab) {
            background-color: #d0d0d0;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active-tab-content {
            display: block;
        }

        #archivo-subir {
            border: 2px dashed #aaa;
            padding: 20px;
            text-align: center;
            margin-bottom: 15px;
            cursor: pointer;
            background-color: #f0f0f0;
            border-radius: 8px;
            transition: background-color 0.3s;
        }

        #archivo-subir:hover {
            background-color: #e9e9e9;
        }

        /* Styles for the paste textarea */
        #binary-paste-textarea {
            width: 100%;
            min-height: 80px;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 8px;
            box-sizing: border-box;
            margin-top: 10px;
            resize: vertical;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #html-preview-textarea {
            width: 100%;
            min-height: 150px;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 8px;
            box-sizing: border-box;
            margin-top: 10px;
            resize: vertical;
            font-family: 'Courier New', monospace;
        }

        #open-html-new-tab-button {
            background-color: #28a745;
            color: white;
            padding: 8px 12px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
            margin-right: 5px;
            transition: background-color 0.3s;
        }

        #open-html-new-tab-button:hover {
            background-color: #218838;
        }

        #archivos-lista,
        #documents-lista {
            list-style-type: none;
            padding: 0;
        }

        #archivos-lista li,
        #documents-lista li {
            border-bottom: 1px solid #eee;
            padding: 8px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9em;
        }

        .archivo-iconos {
            display: flex;
            gap: 10px;
        }

        .archivo-iconos a {
            cursor: pointer;
            text-decoration: none;
            color: #555;
            font-size: 1.2em;
            transition: color 0.3s;
        }

        .archivo-iconos a:hover {
            color: #007bff;
        }

        /* Container for the bottom buttons */
        #bottom-buttons-container {
            width: 90%;
            max-width: 800px;
            margin: 10px auto 20px auto;
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        #html-preview-iframe {
            width: 100%;
            height: 200px;
            border: 1px solid #ccc;
            margin-top: 10px;
            background-color: white;
            border-radius: 5px;
        }

        /* Fullscreen HTML Preview Modal Styles */
        #fullscreen-html-modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.8);
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        #fullscreen-html-modal.active {
            display: flex;
        }

        #fullscreen-html-modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 20px;
            border: 1px solid #888;
            width: 90%;
            height: 90%;
            display: flex;
            flex-direction: column;
            position: relative;
            border-radius: 8px;
        }

        #fullscreen-html-iframe {
            width: 100%;
            height: calc(100% - 40px);
            border: none;
            background-color: white;
        }

        #close-fullscreen-modal-button {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            background: none;
            border: none;
            padding: 0;
        }

        #close-fullscreen-modal-button:hover,
        #close-fullscreen-modal-button:focus {
            color: #000;
            text-decoration: none;
            cursor: pointer;
        }

        /* New styles for web search section */
        #web-searches-content {
            padding: 10px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background-color: #f9f9f9;
            margin-top: 10px;
        }

        #web-searches-content h3 {
            margin-top: 0;
            color: #555;
        }

        #web-searches-content ul {
            list-style-type: none;
            padding: 0;
        }

        #web-searches-content li {
            margin-bottom: 5px;
        }

        #web-searches-content a {
            color: #007bff;
            text-decoration: none;
        }

        #web-searches-content a:hover {
            text-decoration: underline;
        }

        .google-search-suggestions-container {
            margin-top: 15px;
            padding: 10px;
            border: 1px solid #cceeff;
            background-color: #e6f7ff;
            border-radius: 8px;
        }

        /* Styles for the audio preview section */
        #audio-preview-content {
            padding: 10px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background-color: #f9f9f9;
            margin-top: 10px;
        }

        #audio-preview-content h3 {
            margin-top: 0;
            color: #555;
        }

        #audio-preview-content label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        #audio-preview-content select,
        #audio-preview-content textarea,
        #audio-preview-content button {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
        }

        #audio-preview-content button {
            background-color: #007bff;
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        #audio-preview-content button:hover {
            background-color: #0056b3;
        }

        /* Styles for the conversation messages list in the audio tab */
        #conversation-messages-list {
            list-style-type: none;
            padding: 0;
            max-height: 200px; /* Limit height and make it scrollable */
            overflow-y: auto;
            border: 1px solid #eee;
            border-radius: 4px;
            padding: 5px;
        }

        #conversation-messages-list li {
            padding: 5px 0;
            border-bottom: 1px dashed #eee;
            display: flex;
            align-items: flex-start;
        }

        #conversation-messages-list li:last-child {
            border-bottom: none;
        }

        #conversation-messages-list li input[type="checkbox"] {
            margin-right: 10px;
            margin-top: 3px; /* Align checkbox with text */
        }

        #conversation-messages-list li span {
            flex-grow: 1;
            word-break: break-word; /* Ensure long messages wrap */
        }

        /* Styles for the Report button */
        #report-button {
            background-color: white; /* Default inactive */
            color: #ffc107; /* Yellow text */
            border: 1px solid #ffc107; /* Yellow border */
        }

        #report-button.report-active {
            background-color: #ffc107; /* Yellow background */
            color: white; /* White text */
        }

        #report-button:hover {
            opacity: 0.8; /* Slight hover effect */
        }

        /* Styles for the HTML Mode button (now for HTML filtering) */
        #html-mode-button {
            background-color: white; /* Default inactive */
            color: #6f42c1; /* Purple text (like old AI Mode) */
            border: 1px solid #6f42c1; /* Purple border */
        }

        #html-mode-button.html-active {
            background-color: #6f42c1; /* Purple background */
            color: white; /* White text */
        }

        #html-mode-button:hover {
            opacity: 0.8; /* Slight hover effect */
        }

        /* Styles for the Live Mode button */
        #live-mode-button {
            background-color: white; /* Default inactive */
            color: #dc3545; /* Red text */
            border: 1px solid #dc3545; /* Red border */
        }

        #live-mode-button.live-active {
            background-color: #dc3545; /* Red background */
            color: white; /* White text */
        }

        #live-mode-button:hover {
            opacity: 0.8; /* Slight hover effect */
        }

        /* Styles for the Live Mode Choice Modal */
        #live-mode-choice-modal {
            display: none; /* Hidden by default */
            position: fixed;
            z-index: 2001; /* Above other modals */
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.6);
            justify-content: center;
            align-items: center;
        }

        #live-mode-choice-content {
            background-color: #fefefe;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            text-align: center;
            max-width: 400px;
            width: 90%;
            position: relative;
        }

        #live-mode-choice-content h3 {
            margin-top: 0;
            color: #333;
            font-size: 1.2em;
            margin-bottom: 20px;
        }

        #live-mode-choice-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap; /* Allow buttons to wrap on smaller screens */
        }

        #live-mode-choice-buttons button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s, transform 0.2s;
            flex: 1 1 auto; /* Allow buttons to grow and shrink */
            min-width: 120px; /* Minimum width for buttons */
        }

        #live-mode-choice-buttons button:hover {
            transform: translateY(-2px);
        }

        #choose-front-camera-button, /* New ID */
        #choose-rear-camera-button { /* New ID */
            background-color: #28a745;
            color: white;
        }

        #choose-front-camera-button:hover,
        #choose-rear-camera-button:hover {
            background-color: #218838;
        }

        #choose-screen-button {
            background-color: #007bff;
            color: white;
        }

        #choose-screen-button:hover {
            background-color: #0056b3;
        }

        #choose-microphone-button {
            background-color: #ffc107;
            color: white;
        }

        #choose-microphone-button:hover {
            background-color: #e0a800;
        }

        #close-live-choice-modal-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 1.5em;
            cursor: pointer;
            color: #555;
        }

        #close-live-choice-modal-button:hover {
            color: #000;
        }

        /* Recording indicator styles */
        #recording-indicator {
            display: none;
            color: #dc3545; /* Red color */
            font-weight: bold;
            margin-top: 10px;
            font-size: 0.9em;
        }

        /* New styles for the live chat input bar */
        #live-chat-bar {
            width: 90%;
            max-width: 800px;
            margin: 10px auto;
            display: flex;
            gap: 10px;
            align-items: center;
            background-color: #fff;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            position: fixed; /* Fixed position */
            bottom: 20px; /* 20px from bottom */
            left: 50%; /* Center horizontally */
            transform: translateX(-50%); /* Center horizontally */
            z-index: 100; /* Above other content */
            display: none; /* Hidden by default */
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }

        #live-chat-bar.active {
            display: flex; /* Show when active */
        }

        #live-message-input {
            flex-grow: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            min-width: 150px;
        }


        /* Responsive adjustments */
        @media (max-width: 600px) {
            #chat-container, #input-container, #bottom-buttons-container, #live-chat-bar {
                width: 95%;
                margin-left: auto;
                margin-right: auto;
            }

            #input-container, #live-chat-bar {
                flex-direction: column;
                align-items: stretch;
            }

            #send-button,
            #read-button,
            #download-pdf-button,
            #archivos-button,
            #report-button,
            #html-mode-button,
            #live-mode-button,
            label[for="file-input"],
            #send-live-message-button { /* Added to responsive styles */
                width: 100%;
                text-align: center;
            }

            #archivo-menu {
                width: 100%;
                right: -100%;
            }
            #archivo-menu.active {
                right: 0;
            }
        }
    </style>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.css"
        xintegrity="sha512-vDnqY12kF+30rx1J1/yYkRb1sJmJ/R5h30V0fC6wzK+9J80/32Y6M+j692sY6F6w5kK3e9iXN7zHq8yW4+9Vw=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

</head>

<body>

    <div id="chat-container"></div>

    <div id="live-preview-container" style="display: none; width: 90%; max-width: 800px; margin: 10px auto; text-align: center;">
        <video id="live-video-preview" autoplay style="width: 100%; max-height: 250px; border-radius: 8px; background-color: black;"></video>
        <canvas id="audio-waveform-canvas" style="display: none; width: 100%; max-height: 250px; border-radius: 8px; background-color: #f0f0f0;"></canvas>
        <div id="recording-indicator" style="display: none;">Grabando audio... <i class="fas fa-microphone-alt"></i></div>
        <canvas id="live-canvas-capture" style="display: none;"></canvas>
    </div>

    <div id="input-container">
        <input type="text" id="message-input" placeholder="Escribe tu mensaje...">
        <label for="file-input">Adjuntar Archivos</label>
        <input type="file" id="file-input" accept="image/*, application/pdf, audio/*, video/*" multiple>
        <button id="send-button">Enviar</button>
    </div>

    <!-- New Live Chat Bar -->
    <div id="live-chat-bar">
        <input type="text" id="live-message-input" placeholder="Escribe tu mensaje en directo...">
        <button id="send-live-message-button">Enviar Directo</button>
    </div>
    <!---------------------->

    <div id="bottom-buttons-container">
        <button id="read-button"><i class="fas fa-volume-up"></i> Escuchar</button>
        <button id="report-button"><i class="fas fa-file-alt"></i> Informe</button>
        <button id="html-mode-button"><i class="fas fa-code"></i> Modo HTML</button>
        <button id="live-mode-button"><i class="fas fa-video"></i> Directo</button>
        <button id="download-pdf-button">Descargar PDF</button>
        <button id="archivos-button" style="background-color: #007bff;">MAS</button>
        <select id="font-size">
            <option value="10">10</option>
            <option value="12">12</option>
            <option value="14">14</option>
            <option value="16" selected>16</option>
            <option value="18">18</option>
            <option value="20">20</option>
            <option value="24">24</option>
        </select>
    </div>


    <div id="archivo-menu">
        <h2>Archivos</h2>
        <button id="close-menu-button">&times;</button>
        <div class="tab-buttons">
            <button id="tab-button-files" class="active-tab">Archivos</button>
            <button id="tab-button-html-preview">Previsualizar HTML</button>
            <button id="tab-button-documents">Documentos</button>
            <button id="tab-button-web-searches">Búsquedas Web</button>
            <button id="tab-button-audio-preview">Audio</button>
        </div>

        <div id="tab-content-files" class="tab-content active-tab-content">
            <div id="archivo-subir">
                <p>Arrastra y suelta archivos aquí, o haz clic para subir.</p>
                <input type="file" id="archivo-subir-input" style="display: none;" multiple>
            </div>
            <p>O pega imágenes o archivos aquí:</p>
            <textarea id="binary-paste-textarea" placeholder="Pega imágenes o archivos del portapapeles..."></textarea>
            <h3>Archivos subidos en esta conversación:</h3>
            <ul id="archivos-lista">
            </ul>
        </div>

        <div id="tab-content-html-preview" class="tab-content">
            <p>Pega tu código HTML aquí para previsualizarlo:</p>
            <textarea id="html-preview-textarea" placeholder="<!DOCTYPE html><html>...</html>"></textarea>
            <button id="open-html-new-tab-button">Abrir HTML</button>
            <iframe id="html-preview-iframe" sandbox="allow-scripts allow-same-origin" style="width:100%; height:200px; border:1px solid #ccc; margin-top:10px;"></iframe>
        </div>

        <div id="tab-content-documents" class="tab-content">
            <h3>Documentos en esta conversación:</h3>
            <ul id="documents-lista"></ul>
        </div>

        <div id="tab-content-web-searches" class="tab-content">
            <h3>Resultados de Búsqueda de Google:</h3>
            <div id="google-search-suggestions-container" class="google-search-suggestions-container">
                </div>
            <h3>Fuentes:</h3>
            <ul id="web-search-sources-list">
                </ul>
        </div>

        <div id="tab-content-audio-preview" class="tab-content">
            <h3>Previsualizar Audio</h3>
            <label for="preview-audio-voice-selector">Seleccionar Voz:</label>
            <select id="preview-audio-voice-selector"></select>

            <label for="custom-audio-text-prefix">Prefijo de Audio (opcional):</label>
            <textarea id="custom-audio-text-prefix" placeholder="Escribe un prefijo para el audio..."></textarea>

            <label for="custom-audio-text-suffix">Sufijo de Audio (opcional):</label>
            <textarea id="custom-audio-text-suffix" placeholder="Escribe un sufijo para el audio..."></textarea>

            <label for="custom-audio-textarea">Texto Personalizado para Audio:</label>
            <textarea id="custom-audio-textarea" placeholder="Escribe o selecciona mensajes para generar audio..."></textarea>
            <button id="play-selected-message-button">Reproducir Texto Personalizado</button>
            <button id="generate-selected-messages-audio-button">Generar Audio de Seleccionados</button>

            <h3>Mensajes de la Conversación:</h3>
            <ul id="conversation-messages-list"></ul>
        </div>

        </div>

    <div id="fullscreen-html-modal">
        <div id="fullscreen-html-modal-content">
            <button id="close-fullscreen-modal-button">&times;</button>
            <iframe id="fullscreen-html-iframe" sandbox="allow-scripts allow-same-origin"></iframe>
        </div>
    </div>

    <div id="live-mode-choice-modal">
        <div id="live-mode-choice-content">
            <button id="close-live-choice-modal-button">&times;</button>
            <h3>Elige la fuente para el modo Directo:</h3>
            <div id="live-mode-choice-buttons">
                <button id="choose-front-camera-button"><i class="fas fa-camera-retro"></i> Cámara Frontal</button> <button id="choose-rear-camera-button"><i class="fas fa-camera"></i> Cámara Trasera</button> <button id="choose-screen-button"><i class="fas fa-desktop"></i> Pantalla</button>
                <button id="choose-microphone-button"><i class="fas fa-microphone-alt"></i> Micrófono</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/showdown/2.1.0/showdown.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js"
        xintegrity="sha512-vDnqY12kF+30rx1J1/yYkRb1sJmJ/R5h30V0fC6wzK+9J80/32Y6M+j692sY6F6w5kK3e9iXN7zHq8yW4+9Vw=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js"
        xintegrity="sha512-nL+yR6gCg+1X0s89QfC62Kq0L0N2i3J6mY/6d5q3g1K0K2W18w5+6L/w/6xQ5y2E8f5mO98i5M5j5L5w=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <script>
        // Get references to DOM elements
        const chatContainer = document.getElementById('chat-container');
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const fileInput = document.getElementById('file-input');
        const readButton = document.getElementById('read-button');
        const downloadPdfButton = document.getElementById('download-pdf-button');
        const fontSizeSelector = document.getElementById('font-size');

        // Elements of the file menu
        const archivosButton = document.getElementById('archivos-button');
        const archivoMenu = document.getElementById('archivo-menu');
        const archivosLista = document.getElementById('archivos-lista');
        const archivoSubir = document.getElementById('archivo-subir');
        const archivoSubirInput = document.getElementById('archivo-subir-input');
        const binaryPasteTextarea = document.getElementById('binary-paste-textarea');
        const closeMenuButton = document.getElementById('close-menu-button');

        // HTML Preview elements
        const tabButtonFiles = document.getElementById('tab-button-files');
        const tabButtonHtmlPreview = document.getElementById('tab-button-html-preview');
        const tabContentFiles = document.getElementById('tab-content-files');
        const tabContentHtmlPreview = document.getElementById('tab-content-html-preview');
        const htmlPreviewTextarea = document.getElementById('html-preview-textarea');
        const htmlPreviewIframe = document.getElementById('html-preview-iframe');
        const openHtmlNewTabButton = document.getElementById('open-html-new-tab-button');

        // Documents elements
        const tabButtonDocuments = document.getElementById('tab-button-documents');
        const tabContentDocuments = document.getElementById('tab-content-documents');
        const documentsLista = document.getElementById('documents-lista');

        // New Web Searches elements
        const tabButtonWebSearches = document.getElementById('tab-button-web-searches');
        const tabContentWebSearches = document.getElementById('tab-content-web-searches');
        const googleSearchSuggestionsContainer = document.getElementById('google-search-suggestions-container');
        const webSearchSourcesList = document.getElementById('web-search-sources-list');

        // Audio preview elements
        const tabButtonAudioPreview = document.getElementById('tab-button-audio-preview');
        const tabContentAudioPreview = document.getElementById('tab-content-audio-preview');
        const previewAudioVoiceSelector = document.getElementById('preview-audio-voice-selector');
        const customAudioTextarea = document.getElementById('custom-audio-textarea');
        const customAudioTextPrefix = document.getElementById('custom-audio-text-prefix');
        const customAudioTextSuffix = document.getElementById('custom-audio-text-suffix');
        const playSelectedMessageButton = document.getElementById('play-selected-message-button');
        const generateSelectedMessagesAudioButton = document.getElementById('generate-selected-messages-audio-button');
        const conversationMessagesList = document.getElementById('conversation-messages-list');

        // Report elements
        const reportButton = document.getElementById('report-button');

        // HTML Mode elements (now controls HTML filtering)
        const htmlModeButton = document.getElementById('html-mode-button');

        // New Live Mode elements
        const liveModeButton = document.getElementById('live-mode-button');
        const livePreviewContainer = document.getElementById('live-preview-container');
        const liveVideoPreview = document.getElementById('live-video-preview');
        const audioWaveformCanvas = document.getElementById('audio-waveform-canvas'); // New canvas for waveform
        const liveCanvasCapture = document.getElementById('live-canvas-capture');
        const recordingIndicator = document.getElementById('recording-indicator'); // New recording indicator
        let currentStream = null; // To hold the media stream

        // Live Mode Choice Modal elements
        const liveModeChoiceModal = document.getElementById('live-mode-choice-modal');
        const chooseFrontCameraButton = document.getElementById('choose-front-camera-button'); // New ID
        const chooseRearCameraButton = document.getElementById('choose-rear-camera-button'); // New ID
        const chooseScreenButton = document.getElementById('choose-screen-button');
        const chooseMicrophoneButton = document.getElementById('choose-microphone-button');
        const closeLiveChoiceModalButton = document.getElementById('close-live-choice-modal-button');

        // New Live Chat Bar elements
        const liveChatBar = document.getElementById('live-chat-bar');
        const liveMessageInput = document.getElementById('live-message-input');
        const sendLiveMessageButton = document.getElementById('send-live-message-button');


        // Fullscreen HTML Modal elements
        const fullscreenHtmlModal = document.getElementById('fullscreen-html-modal');
        const fullscreenHtmlIframe = document.getElementById('fullscreen-html-iframe');
        const closeFullscreenModalButton = document.getElementById('close-fullscreen-modal-button');

        // API Key for Gemini. Reverted to the user's original API key.
        const apiKey = 'AIzaSyD2Z5cvFOrS7fiHBY2KymJ7dT4UgmYOrVA';
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;


        let history = []; // Stores the chat history for the Gemini API
        const showdownConverter = new showdown.Converter(); // Markdown to HTML converter
        let selectedMessagesTexts = []; // Stores text of selected messages for audio generation
        let isReportModeActive = false; // State for report mode
        let isHtmlModeActive = false; // Controls HTML filtering
        let isLiveModeActive = false; // New state for live mode

        // Audio recording specific variables
        let audioContext;
        let analyser;
        let mediaRecorder;
        let audioChunks = [];
        let isRecordingAudio = false;
        let silenceStartTime = 0;
        const AUDIO_THRESHOLD = 120; // Adjust as needed (0-255, higher is louder)
        const SILENCE_DURATION_MS = 1000; // 1 second of silence to stop recording
        let audioProcessAnimationFrameId; // To store the requestAnimationFrame ID

        // Global variables for audio waveform drawing and detection
        let bufferLength;
        let dataArray;


        // Define retry prompts and max retries for Gemini's HTML generation
        const HTML_RETRY_PROMPTS = [
            "Por favor, genera el código HTML completo, incluyendo `<!DOCTYPE html>`, `<html>`, `<head>`, y `<body>`.",
            "Necesito el HTML completo. Asegúrate de que sea un documento HTML válido y autocontenido.",
            "Proporciona el HTML completo, empezando con `<!DOCTYPE html>`. No incluyas texto adicional.",
            "Intenta de nuevo y genera solo el código HTML completo y bien formado.",
            "Por favor, genera un documento HTML completo y válido. No añadas explicaciones ni texto que no sea HTML."
        ];
        const MAX_RETRIES = 5;
        const HTML_GENERATION_INSTRUCTION = "genera todo el codigo html sin explicaciones solo el codigo empezando por doctype html. ";


        // Function to render mathematical expressions with KaTeX
        function renderMath() {
            renderMathInElement(document.body, {
                delimiters: [
                    { left: '$$', right: '$$', display: true },
                    { left: '$', right: '$', display: false },
                    { left: '\\(', right: '\\)', display: false },
                    { left: '\\[', right: '\\]', display: true }
                ],
                throwOnError: false
            });
        }

        // Function to highlight code within Markdown blocks
        function highlightCode(text) {
            // Apply syntax highlighting for common keywords, strings, comments, and numbers
            text = text.replace(/(const|let|var|function|return|if|else|for|while|switch|case|break|continue|try|catch|finally|class|extends|super|import|export|this|new|await|async)/g, '<span class="keyword">$1</span>');
            text = text.replace(/(['"])(.*?)(['"])/g, '<span class="string">$1$2$3</span>');
            text = text.replace(/(\/\/.*)/g, '<span class="comment">$1</span>');
            text = text.replace(/(\/\*[\s\S]*?\*\/)/g, '<span class="comment">$1</span>'); // Multi-line comments
            text = text.replace(/(\b\d+\.?\d*|\.\d+\b)/g, '<span class="number">$1</span>'); // Numbers
            return text;
        }

        // Function to populate voice options for speech synthesis
        function populateVoiceList() {
            const voices = speechSynthesis.getVoices();
            previewAudioVoiceSelector.innerHTML = ''; // Clear existing options
            voices.forEach(voice => {
                const option = document.createElement('option');
                option.textContent = `${voice.name} (${voice.lang})`;
                option.value = voice.name;
                // Set default Spanish voice if available
                if (voice.lang === 'es-ES' && voice.name.includes('Google español')) {
                    option.selected = true;
                }
                previewAudioVoiceSelector.appendChild(option);
            });
        }

        // Populate voices when they are loaded
        if (speechSynthesis.onvoiceschanged !== undefined) {
            speechSynthesis.onvoiceschanged = populateVoiceList;
        }
        populateVoiceList(); // Call initially in case voices are already loaded

        // Function to play audio for a given text
        async function playAudioForText(text, voiceName, buttonElement) {
            if (!text) {
                console.log('No text to play.');
                return;
            }

            // Disable the button and show a loading indicator
            if (buttonElement) {
                buttonElement.disabled = true;
                buttonElement.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Generando...';
            }

            const utterance = new SpeechSynthesisUtterance(text);
            const voices = speechSynthesis.getVoices();
            const selectedVoice = voices.find(voice => voice.name === voiceName);

            if (selectedVoice) {
                utterance.voice = selectedVoice;
            } else {
                utterance.lang = 'es-ES'; // Fallback to Spanish if specific voice not found
            }

            utterance.onend = () => {
                if (buttonElement) {
                    buttonElement.disabled = false;
                    // Restore original button text based on its ID
                    if (buttonElement.id === 'play-selected-message-button') {
                        buttonElement.innerHTML = 'Reproducir Texto Personalizado';
                    } else if (buttonElement.id === 'generate-selected-messages-audio-button') {
                        buttonElement.innerHTML = 'Generar Audio de Seleccionados';
                    }
                }
            };

            utterance.onerror = (event) => {
                console.error('SpeechSynthesisUtterance.onerror', event);
                if (buttonElement) {
                    buttonElement.disabled = false;
                    if (buttonElement.id === 'play-selected-message-button') {
                        buttonElement.innerHTML = 'Reproducir Texto Personalizado';
                    } else if (buttonElement.id === 'generate-selected-messages-audio-button') {
                        buttonElement.innerHTML = 'Generar Audio de Seleccionados';
                    }
                }
            };

            speechSynthesis.speak(utterance);
        }

        // Function to populate the conversation messages list in the Audio tab
        function populateConversationMessagesList() {
            conversationMessagesList.innerHTML = ''; // Clear existing list
            const messages = document.querySelectorAll('.user-message, .gemini-message');
            messages.forEach((messageDiv, index) => {
                const listItem = document.createElement('li');
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `msg-${index}`;
                checkbox.dataset.index = index;
                checkbox.addEventListener('change', updateSelectedMessages);

                const messageTextSpan = document.createElement('span');
                messageTextSpan.textContent = messageDiv.textContent;

                listItem.appendChild(checkbox);
                listItem.appendChild(messageTextSpan);
                conversationMessagesList.appendChild(listItem);
            });
            updateSelectedMessages(); // Update the textarea based on current selection
        }

        // Function to update the selected messages text area
        function updateSelectedMessages() {
            selectedMessagesTexts = [];
            const checkboxes = conversationMessagesList.querySelectorAll('input[type="checkbox"]:checked');
            checkboxes.forEach(checkbox => {
                const index = parseInt(checkbox.dataset.index);
                const messageDiv = document.querySelectorAll('.user-message, .gemini-message')[index];
                if (messageDiv) {
                    selectedMessagesTexts.push(messageDiv.textContent);
                }
            });

            const prefix = customAudioTextPrefix.value.trim();
            const suffix = customAudioTextSuffix.value.trim();

            let combinedText = selectedMessagesTexts.join('\n\n');
            if (prefix) {
                combinedText = prefix + '\n\n' + combinedText;
            }
            if (suffix) {
                combinedText = combinedText + '\n\n' + suffix;
            }
            customAudioTextarea.value = combinedText;
        }

        // Function to display a message in the chat (for system messages)
        function displaySystemMessage(messageText) {
            const systemMessageDiv = document.createElement('div');
            systemMessageDiv.className = 'gemini-message'; // Use gemini-message style for system messages
            systemMessageDiv.textContent = messageText;
            chatContainer.appendChild(systemMessageDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        // Function to update the input placeholder based on active modes
        function updateInputPlaceholder() {
            if (isReportModeActive) {
                messageInput.placeholder = "Escribe las indicaciones de tu informe";
            } else if (isLiveModeActive) {
                if (currentStream && currentStream.getVideoTracks().length > 0) {
                    messageInput.placeholder = "Escribe tu mensaje y adjunta una imagen de la cámara/pantalla...";
                } else if (currentStream && currentStream.getAudioTracks().length > 0) {
                    messageInput.placeholder = "Habla para grabar audio...";
                } else {
                    messageInput.placeholder = "Escribe tu mensaje...";
                }
            }
            else {
                messageInput.placeholder = "Escribe tu mensaje...";
            }
        }

        // New function to send to Gemini specifically for HTML generation with retries
        async function sendToGeminiForHtmlOnly(messageToSendToGemini, originalUserMessage, fileDataArray, retryCount = 0) {
            let prompt = messageToSendToGemini;
            if (retryCount > 0) {
                prompt = HTML_RETRY_PROMPTS[retryCount - 1] || HTML_RETRY_PROMPTS[HTML_RETRY_PROMPTS.length - 1];
                // No longer showing retry messages in chat
            }

            // Create a payload for Gemini, ensuring the last user message in history is the current prompt
            let payloadContents = JSON.parse(JSON.stringify(history)); // Deep copy

            // Find the last user message in payloadContents and update its parts
            let lastUserMessageIndex = -1;
            for (let i = payloadContents.length - 1; i >= 0; i--) {
                if (payloadContents[i].role === 'user') {
                    lastUserMessageIndex = i;
                    break;
                }
            }

            if (lastUserMessageIndex !== -1) {
                // Ensure the text part is the prompt for Gemini
                payloadContents[lastUserMessageIndex].parts = [{ text: prompt }];

                // Add file data to the last user message's parts
                if (fileDataArray && fileDataArray.length > 0) {
                    fileDataArray.forEach(file => {
                        payloadContents[lastUserMessageIndex].parts.push({
                            inlineData: {
                                mimeType: file.mimeType,
                                data: file.data
                            }
                        });
                    });
                }
            } else {
                // This case should ideally not happen if history is managed correctly,
                // but as a fallback, create a new user message with text and files.
                const newParts = [{ text: prompt }];
                if (fileDataArray && fileDataArray.length > 0) {
                    newParts.push(...fileDataArray.map(file => ({
                        inlineData: {
                            mimeType: file.mimeType,
                            data: file.data
                        }
                    })));
                }
                payloadContents.push({ role: 'user', parts: newParts });
            }


            try {
                const payload = {
                    contents: payloadContents,
                    generationConfig: {
                        temperature: 1,
                        topP: 0.95,
                        topK: 40,
                        maxOutputTokens: 8192,
                    },
                    tools: [{ googleSearch: {} }],
                };

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(payload),
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('API response not OK (Gemini HTML generation):', response.status, response.statusText, errorText);
                    throw new Error(`API error (Gemini HTML generation): ${response.status} ${response.statusText} - ${errorText}`);
                }

                const data = await response.json();

                if (data.candidates && data.candidates.length > 0) {
                    let geminiResponse = data.candidates[0].content.parts[0].text;
                    console.log("Raw Gemini HTML Response:", geminiResponse);

                    const htmlMatch = geminiResponse.includes('<!DOCTYPE html>'); // Check for full HTML

                    if (htmlMatch) {
                        htmlPreviewTextarea.value = geminiResponse;
                        const iframeDoc = htmlPreviewIframe.contentWindow.document;
                        iframeDoc.open();
                        iframeDoc.write(geminiResponse);
                        iframeDoc.close();
                        showTab('tab-content-html-preview');
                        // Format for chat display if it's HTML
                        geminiResponse = `Aquí está el código HTML generado:\n\n\`\`\`html\n${geminiResponse}\n\`\`\``;

                        // Display Gemini's response in chat
                        let responseHtml = showdownConverter.makeHtml(geminiResponse);
                        responseHtml = responseHtml.replace(/(-b ± √(b² - 4ac)) \/ 2a/g, '<span class="katex">\\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}</span>');
                        responseHtml = responseHtml.replace(/x\^2/g, '<span class="katex">x^2</span>');
                        responseHtml = responseHtml.replace(/a\/b/g, '<span class="katex">\\frac{a}{b}</span>');
                        responseHtml = responseHtml.replace(/\\sqrt\{(\w+)\}/g, '<span class="katex">\\sqrt{$1}</span>');
                        responseHtml = responseHtml.replace(/\\sqrt\{(b\^2 - 4ac)\}/g, '<span class="katex">\\sqrt{b^2 - 4ac}</span>');
                        responseHtml = responseHtml.replace(/(\\frac\{\w+\}\{\w+\})/g, '<span class="katex">$1</span>');
                        responseHtml = responseHtml.replace(/<pre><code[^>]*>([\s\S]*?)<\/code><\/pre>/g, (match, code) => {
                            const highlightedCode = highlightCode(code.trim());
                            return `<pre><code class="code-block">${highlightedCode}</code></pre>`;
                        });

                        history.push({ role: 'model', parts: [{ text: geminiResponse }] });

                        const geminiMessageDiv = document.createElement('div');
                        geminiMessageDiv.className = 'gemini-message';
                        geminiMessageDiv.innerHTML = responseHtml;
                        chatContainer.appendChild(geminiMessageDiv);
                        chatContainer.scrollTop = chatContainer.scrollHeight;
                        renderMath();
                        populateConversationMessagesList();

                    } else {
                        // If no full HTML and retries available, retry
                        if (retryCount < MAX_RETRIES) {
                            // Add the model's non-HTML response to history for context, but don't display it
                            history.push({ role: 'model', parts: [{ text: `Respuesta de Gemini (no HTML completo): ${geminiResponse.substring(0, 200)}...` }] });
                            await sendToGeminiForHtmlOnly(originalUserMessage, originalUserMessage, fileDataArray, retryCount + 1); // Pass original user message for retries
                        } else {
                            // Max retries reached, display original response with a message
                            displaySystemMessage('Gemini no pudo generar un código HTML completo después de varios intentos. Mostrando la respuesta tal cual.');
                            let responseHtml = showdownConverter.makeHtml(geminiResponse);
                            responseHtml = responseHtml.replace(/(-b ± √(b² - 4ac)) \/ 2a/g, '<span class="katex">\\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}</span>');
                            responseHtml = responseHtml.replace(/x\^2/g, '<span class="katex">x^2</span>');
                            responseHtml = responseHtml.replace(/a\/b/g, '<span class="katex">\\frac{a}{b}</span>');
                            responseHtml = responseHtml.replace(/\\sqrt\{(\w+)\}/g, '<span class="katex">\\sqrt{$1}</span>');
                            responseHtml = responseHtml.replace(/\\sqrt\{(b\^2 - 4ac)\}/g, '<span class="katex">\\sqrt{b^2 - 4ac}</span>');
                            responseHtml = responseHtml.replace(/(\\frac\{\w+\}\{\w+\})/g, '<span class="katex">$1</span>');
                            responseHtml = responseHtml.replace(/<pre><code[^>]*>([\s\S]*?)<\/code><\/pre>/g, (match, code) => {
                                const highlightedCode = highlightCode(code.trim());
                                return `<pre><code class="code-block">${highlightedCode}</code></pre>`;
                            });

                            history.push({ role: 'model', parts: [{ text: geminiResponse }] });

                            const geminiMessageDiv = document.createElement('div');
                            geminiMessageDiv.className = 'gemini-message';
                            geminiMessageDiv.innerHTML = responseHtml;
                            chatContainer.appendChild(geminiMessageDiv);
                            chatContainer.scrollTop = chatContainer.scrollHeight;
                            renderMath();
                            populateConversationMessagesList();
                        }
                    }

                    // Display grounding metadata if available (for both HTML and non-HTML responses)
                    if (data.candidates[0].groundingMetadata) {
                        const groundingMetadata = data.candidates[0].groundingMetadata;
                        if (groundingMetadata.searchEntryPoint && groundingMetadata.searchEntryPoint.renderedContent) {
                            googleSearchSuggestionsContainer.innerHTML = groundingMetadata.searchEntryPoint.renderedContent;
                        }
                        if (groundingMetadata.groundingChunks && groundingMetadata.groundingChunks.length > 0) {
                            groundingMetadata.groundingChunks.forEach(chunk => {
                                if (chunk.web && chunk.web.uri && chunk.web.title) {
                                    const listItem = document.createElement('li');
                                    const link = document.createElement('a');
                                    link.href = chunk.web.uri;
                                    link.textContent = chunk.web.title;
                                    link.target = '_blank';
                                    listItem.appendChild(link);
                                    webSearchSourcesList.appendChild(listItem);
                                }
                            });
                        }
                        if (googleSearchSuggestionsContainer.innerHTML || webSearchSourcesList.innerHTML) {
                            archivoMenu.classList.add('active');
                            showTab('tab-content-web-searches');
                        }
                    }

                } else {
                    displaySystemMessage('Error: Gemini no pudo obtener una respuesta para la generación de HTML.');
                }
            } catch (error) {
                console.error('Error al enviar mensaje a Gemini para HTML:', error);
                displaySystemMessage(`Error al generar HTML: ${error.message}`);
            } finally {
                // fileDataArray is cleared by the initial sendMessage call
            }
        }

        // Modify the original sendMessage to branch based on active modes
        async function sendMessage(message, fileDataArray) {
            // If live mode is active and it's a video stream (camera/screen), capture an image
            if (isLiveModeActive && currentStream && currentStream.getVideoTracks().length > 0) {
                const video = liveVideoPreview;
                const canvas = liveCanvasCapture;
                const context = canvas.getContext('2d');

                // Set canvas dimensions to video dimensions
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;

                // Draw the current video frame onto the canvas
                context.drawImage(video, 0, 0, canvas.width, canvas.height);

                // Get the image data as a Base64 string
                const imageDataUrl = canvas.toDataURL('image/png');
                const base64Data = imageDataUrl.split(',')[1];

                const newFile = {
                    name: `live_capture_${Date.now()}.png`,
                    mimeType: 'image/png',
                    data: base64Data,
                    url: imageDataUrl
                };

                fileDataArray.push(newFile);
                uploadedFiles.push(newFile); // Add to overall uploaded files
                renderAllUploadedLists(); // Update displayed lists
                displaySystemMessage("Imagen capturada de la cámara/pantalla y adjuntada a archivos.");
            }


            // Construct the parts for the current user message including text and files
            const userMessageParts = [{ text: message }];
            if (fileDataArray && fileDataArray.length > 0) {
                fileDataArray.forEach(file => {
                    userMessageParts.push({
                        inlineData: {
                            mimeType: file.mimeType,
                            data: file.data // Base64 encoded data
                        }
                    });
                });
            }

            // Update history with the full user message parts
            history.push({ role: 'user', parts: userMessageParts });

            // Display the user message in the chat UI
            const userMessageDiv = document.createElement('div');
            userMessageDiv.className = 'user-message';
            let messageHtml = showdownConverter.makeHtml(message); // Convert Markdown to HTML
            userMessageDiv.innerHTML = messageHtml;

            chatContainer.appendChild(userMessageDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight; // Scroll to bottom


            if (isHtmlModeActive) { // If HTML Mode (filtering and retry) is active
                const fullHtmlPrompt = HTML_GENERATION_INSTRUCTION + message;
                await sendToGeminiForHtmlOnly(fullHtmlPrompt, message, fileDataArray); // Pass original message for retries
            } else {
                // If HTML mode is NOT active, proceed with the original Gemini logic (including report mode)
                let payloadContents = JSON.parse(JSON.stringify(history)); // Deep copy
                // The last message in history (which is the current user message) already contains the parts with text and files.
                // We just need to modify the text part if report mode is active.
                let currentMessageTextPart = payloadContents[payloadContents.length - 1].parts.find(part => part.text);

                // Define the system instruction based on report mode
                let systemInstruction = "Eres un asistente de IA útil y amigable. Responde a la pregunta del usuario. No incluyas ningún otro texto o ```html.";
                if (isReportModeActive) {
                    // Updated system instruction for report mode
                    systemInstruction = "Estás en modo informe. Tu única tarea es generar un informe detallado y comprensible basado en la solicitud del usuario y el historial de chat. Tu respuesta debe ser *directamente* el informe, sin preámbulos, despedidas, ni ningún otro texto conversacional. Genera el informe como respuesta a esta solicitud. Incluye la webgrafía de la mayor cantidad de sitios visitados al final del informe.";
                }

                try {
                    const payload = {
                        contents: payloadContents,
                        generationConfig: {
                            temperature: 1,
                            topP: 0.95,
                            topK: 40,
                            maxOutputTokens: 8192,
                        },
                        tools: [{ googleSearch: {} }],
                        // Add system instruction to payload
                        systemInstruction: {
                            parts: [{ text: systemInstruction }]
                        }
                    };

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(payload),
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error('API response not OK (normal mode):', response.status, response.statusText, errorText);
                        throw new Error(`API error: ${response.status} ${response.statusText} - ${errorText}`);
                    }

                    const data = await response.json();

                    if (data.candidates && data.candidates.length > 0) {
                        let geminiResponse = data.candidates[0].content.parts[0].text;
                        console.log("Raw Gemini Response (normal mode):", geminiResponse);

                        // Display grounding metadata and handle report mode as before
                        if (data.candidates[0].groundingMetadata) {
                            const groundingMetadata = data.candidates[0].groundingMetadata;
                            if (groundingMetadata.searchEntryPoint && groundingMetadata.searchEntryPoint.renderedContent) {
                                googleSearchSuggestionsContainer.innerHTML = groundingMetadata.searchEntryPoint.renderedContent;
                            }
                            if (groundingMetadata.groundingChunks && groundingMetadata.groundingChunks.length > 0) {
                                groundingMetadata.groundingChunks.forEach(chunk => {
                                    if (chunk.web && chunk.web.uri && chunk.web.title) {
                                        const listItem = document.createElement('li');
                                        const link = document.createElement('a');
                                        link.href = chunk.web.uri;
                                        link.textContent = chunk.web.title;
                                        link.target = '_blank';
                                        listItem.appendChild(link);
                                        webSearchSourcesList.appendChild(listItem);
                                    }
                                });
                            }
                            if (googleSearchSuggestionsContainer.innerHTML || webSearchSourcesList.innerHTML) {
                                archivoMenu.classList.add('active');
                                showTab('tab-content-web-searches');
                            }
                        }

                        // The system instruction for report mode now handles the webgrafía inclusion directly.
                        // So, no need to append it here explicitly.

                        // Always display in normal mode
                        let responseHtml = showdownConverter.makeHtml(geminiResponse);
                        responseHtml = responseHtml.replace(/(-b ± √(b² - 4ac)) \/ 2a/g, '<span class="katex">\\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}</span>');
                        responseHtml = responseHtml.replace(/x\^2/g, '<span class="katex">x^2</span>');
                        responseHtml = responseHtml.replace(/a\/b/g, '<span class="katex">\\frac{a}{b}</span>');
                        responseHtml = responseHtml.replace(/\\sqrt\{(\w+)\}/g, '<span class="katex">\\sqrt{$1}</span>');
                        responseHtml = responseHtml.replace(/\\sqrt\{(b\^2 - 4ac)\}/g, '<span class="katex">\\sqrt{b^2 - 4ac}</span>');
                        responseHtml = responseHtml.replace(/(\\frac\{\w+\}\{\w+\})/g, '<span class="katex">$1</span>');
                        responseHtml = responseHtml.replace(/<pre><code[^>]*>([\s\S]*?)<\/code><\/pre>/g, (match, code) => {
                            const highlightedCode = highlightCode(code.trim());
                            return `<pre><code class="code-block">${highlightedCode}</code></pre>`;
                        });

                        history.push({ role: 'model', parts: [{ text: geminiResponse }] });

                        const geminiMessageDiv = document.createElement('div');
                        geminiMessageDiv.className = 'gemini-message';
                        geminiMessageDiv.innerHTML = responseHtml;
                        chatContainer.appendChild(geminiMessageDiv);
                        chatContainer.scrollTop = chatContainer.scrollHeight;
                        renderMath();
                        populateConversationMessagesList();

                    } else {
                        const errorDiv = document.createElement('div');
                        errorDiv.className = 'gemini-message';
                        errorDiv.textContent = 'Error: No se pudo obtener una respuesta del modelo.';
                        chatContainer.appendChild(errorDiv);
                        chatContainer.scrollTop = chatContainer.scrollTop;
                    }
                } catch (error) {
                    console.error('Error al enviar mensaje (normal mode):', error);
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'gemini-message';
                    let displayErrorMessage = 'Error de conexión o del servidor. Inténtalo de nuevo más tarde.';
                    if (error instanceof Error) {
                        displayErrorMessage = `Error: ${error.message}`;
                    } else if (typeof error === 'object' && error !== null) {
                        try {
                            displayErrorMessage = `Error: ${JSON.stringify(error)}`;
                        } catch (e) {
                            displayErrorMessage = `Error: ${error.toString()}`;
                        }
                    } else {
                        displayErrorMessage = `Error: ${String(error)}`;
                    }
                    errorDiv.textContent = displayErrorMessage;
                    chatContainer.appendChild(errorDiv);
                    chatContainer.scrollTop = chatContainer.scrollHeight;
                } finally {
                    fileDataArray = [];
                    fileInput.value = '';
                }
            }
        }

        let fileDataArray = []; // Files attached for the current message
        const uploadedFiles = []; // All files uploaded during the conversation

        // Event listener for send button click
        sendButton.addEventListener('click', () => {
            const message = messageInput.value.trim();

            if (message || fileDataArray.length > 0) {
                sendMessage(message, fileDataArray);
                messageInput.value = '';
            }
        });

        // Event listener for Enter key in message input
        messageInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                sendButton.click();
                event.preventDefault(); // Prevent new line in input
            }
        });

        // Event listener for pasting content into the message input
        messageInput.addEventListener('paste', async (event) => {
            const items = event.clipboardData?.items;
            if (!items) return;

            event.preventDefault(); // Prevent default paste behavior

            let pastedText = '';
            // Iterate through clipboard items to find plain text
            for (const item of items) {
                if (item.type === 'text/plain') {
                    pastedText = event.clipboardData.getData('text/plain');
                    break; // Found plain text, no need to check other types for message input
                }
            }

            // Append pasted plain text to current input value
            if (pastedText) {
                messageInput.value += pastedText;
            }
            // Images and HTML are ignored for direct pasting into messageInput
            // They can still be handled by fileInput or binaryPasteTextarea if needed
        });

        // Event listener for the "Escuchar" (Listen) button
        readButton.addEventListener('click', () => {
            const messages = document.querySelectorAll('.user-message, .gemini-message');
            let fullText = '';
            messages.forEach(message => {
                fullText += message.textContent + '. ';
            });

            const utterance = new SpeechSynthesisUtterance(fullText);
            utterance.lang = 'es-ES'; // Set language to Spanish
            speechSynthesis.speak(utterance);
        });

        // Event listener for the "Descargar PDF" (Download PDF) button
        downloadPdfButton.addEventListener('click', () => {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();

            let yPos = 10;
            const margin = 10;
            const pageWidth = doc.internal.pageSize.width;
            const pageHeight = doc.internal.pageSize.height;
            const maxWidth = pageWidth - 2 * margin; // Max width for text in PDF

            // Function to add text with word wrapping and handle new pages
            function addWrappedText(text, x, y, maxWidth, doc, isBold = false) {
                doc.setFont("helvetica", isBold ? "bold" : "normal");
                const textLines = doc.splitTextToSize(text, maxWidth);
                let currentY = y;

                for (const line of textLines) {
                    // Check if new page is needed before adding the line
                    if (currentY + doc.getTextDimensions(line).h > pageHeight - margin) {
                        doc.addPage();
                        currentY = margin; // Reset Y position for new page
                    }
                    doc.text(line, x, currentY);
                    currentY += doc.getTextDimensions(line).h + 2; // Add line height + small padding
                }
                return currentY - y; // Return total height used for this block
            }

            const messages = document.querySelectorAll('.user-message, .gemini-message');
            messages.forEach(message => {
                let messageText = message.textContent;
                const isUserMessage = message.classList.contains('user-message');

                // Add message text to PDF
                const textHeight = addWrappedText(messageText, margin, yPos, maxWidth, doc, isUserMessage);
                yPos += textHeight + 5; // Add some padding between messages
            });

            doc.save('chat_conversation.pdf');
        });

        // Function to update the font size of the chat messages
        fontSizeSelector.addEventListener('change', (event) => {
            const selectedFontSize = event.target.value + 'px';
            chatContainer.style.fontSize = selectedFontSize;
        });

        // Function to render all uploaded files in both lists (Archivos and Documentos tabs)
        function renderAllUploadedLists() {
            archivosLista.innerHTML = '';
            documentsLista.innerHTML = '';

            uploadedFiles.forEach((file, index) => {
                const listItemHtml = `
                    <span>${file.name}</span>
                    <div class="archivo-iconos">
                        <a href="#" data-index="${index}" class="reattach-file" title="Volver a adjuntar">&#x21BA;</a>
                        <a href="#" data-index="${index}" class="delete-file" title="Eliminar">&#x1F5D1;</a>
                    </div>
                `;

                // Add to "Archivos" tab list
                const fileTabListItem = document.createElement('li');
                fileTabListItem.innerHTML = listItemHtml;
                archivosLista.appendChild(fileTabListItem);

                // Add to "Documentos" tab list
                const docTabListItem = document.createElement('li');
                docTabListItem.innerHTML = listItemHtml;
                documentsLista.appendChild(docTabListItem);
            });
        }

        // Event listener to toggle the file menu visibility
        archivosButton.addEventListener('click', () => {
            archivoMenu.classList.toggle('active');
            if (archivoMenu.classList.contains('active')) {
                showTab('tab-content-files'); // Default to 'Archivos' tab when opening
            }
        });

        // Event listener to close the file menu
        closeMenuButton.addEventListener('click', () => {
            archivoMenu.classList.remove('active');
        });

        // Event listener for file input change (from main chat interface)
        fileInput.addEventListener('change', (event) => {
            const files = event.target.files;
            if (files.length > 0) {
                processFiles(files);
            }
        });

        // Event listener for clicking the "Arrastra y suelta" area to open file input
        archivoSubir.addEventListener('click', (event) => {
            archivoSubirInput.click();
        });

        // Event listener for file input change (from file menu)
        archivoSubirInput.addEventListener('change', (event) => {
            const files = event.target.files;
            if (files.length > 0) {
                processFiles(files);
            }
        });

        // Function to process selected or dropped files
        function processFiles(files) {
            for (const file of files) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const newFile = {
                        name: file.name,
                        mimeType: file.type,
                        data: e.target.result.split(',')[1], // Base64 encoded data
                        url: e.target.result // Full data URL
                    };
                    // Check if file already exists to avoid duplicates
                    const existingFile = uploadedFiles.find(f => f.name === newFile.name && f.mimeType === newFile.mimeType);
                    if (!existingFile) {
                        fileDataArray.push(newFile); // Add to current message's files
                        uploadedFiles.push(newFile); // Add to overall uploaded files
                        renderAllUploadedLists(); // Update displayed lists
                    } else {
                        console.log(`Archivo ya subido: ${newFile.name}`);
                    }
                };
                reader.readAsDataURL(file); // Read file as Data URL (Base64)
            }
        }

        // Drag and drop event listeners for the file upload area
        archivoSubir.addEventListener('dragover', (event) => {
            event.preventDefault();
            archivoSubir.style.backgroundColor = '#e0e0e0';
        });

        archivoSubir.addEventListener('dragleave', (event) => {
            archivoSubir.style.backgroundColor = 'transparent';
        });

        archivoSubir.addEventListener('drop', (event) => {
            event.preventDefault();
            archivoSubir.style.backgroundColor = 'transparent';
            const files = event.dataTransfer.files;
            if (files.length > 0) {
                processFiles(files);
            }
        });

        // Event listener for actions within the uploaded files list (reattach/delete)
        archivosLista.addEventListener('click', (event) => {
            if (event.target.classList.contains('reattach-file')) {
                event.preventDefault();
                const index = parseInt(event.target.dataset.index);
                const fileToReattach = uploadedFiles[index];
                if (fileToReattach) {
                    fileDataArray.push(fileToReattach); // Add to current message's files
                    console.log(`Archivo adjuntado de nuevo: ${fileToReattach.name}`);
                }
            } else if (event.target.classList.contains('delete-file')) {
                event.preventDefault();
                const index = parseInt(event.target.dataset.index);
                const fileToDelete = uploadedFiles[index];

                if (fileToDelete) {
                    // Remove from overall uploaded files
                    uploadedFiles.splice(index, 1);
                    // Also remove from current message's files if it's there
                    const fileDataIndex = fileDataArray.findIndex(f => f.name === fileToDelete.name && f.mimeType === fileToDelete.mimeType);
                    if (fileDataIndex !== -1) {
                        fileDataArray.splice(fileDataIndex, 1);
                    }
                    renderAllUploadedLists(); // Re-render lists to reflect changes
                    console.log(`Archivo eliminado: ${fileToDelete.name}`);
                } else {
                    console.error('Archivo no encontrado para eliminación en el índice:', index);
                }
            }
        });

        // Event listener for actions within the documents list (reattach/delete) - mirrors archivosLista
        documentsLista.addEventListener('click', (event) => {
            if (event.target.classList.contains('reattach-file')) {
                event.preventDefault();
                const index = parseInt(event.target.dataset.index);
                const fileToReattach = uploadedFiles[index];
                if (fileToReattach) {
                    fileDataArray.push(fileToReattach);
                    console.log(`Archivo adjuntado de nuevo desde documentos: ${fileToReattach.name}`);
                }
            } else if (event.target.classList.contains('delete-file')) {
                event.preventDefault();
                const index = parseInt(event.target.dataset.index);
                const fileToDelete = uploadedFiles[index];

                if (fileToDelete) {
                    uploadedFiles.splice(index, 1);
                    const fileDataIndex = fileDataArray.findIndex(f => f.name === fileToDelete.name && f.mimeType === fileToDelete.mimeType);
                    if (fileDataIndex !== -1) {
                        fileDataArray.splice(fileDataIndex, 1);
                    }
                    renderAllUploadedLists();
                    console.log(`Archivo eliminado desde documentos: ${fileToDelete.name}`);
                } else {
                    console.error('Archivo no encontrado para eliminación en el índice:', index);
                }
            }
        });

        // Function to handle tab switching in the file menu
        function showTab(tabId) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active-tab-content');
            });
            // Deactivate all tab buttons
            document.querySelectorAll('.tab-buttons button').forEach(button => {
                button.classList.remove('active-tab');
            });

            // Show the selected tab content
            document.getElementById(tabId).classList.add('active-tab-content');

            // Activate the corresponding tab button
            if (tabId === 'tab-content-files') {
                tabButtonFiles.classList.add('active-tab');
            } else if (tabId === 'tab-content-html-preview') {
                tabButtonHtmlPreview.classList.add('active-tab');
            } else if (tabId === 'tab-content-documents') {
                tabButtonDocuments.classList.add('active-tab');
            } else if (tabId === 'tab-content-web-searches') {
                tabButtonWebSearches.classList.add('active-tab');
            } else if (tabId === 'tab-content-audio-preview') {
                tabButtonAudioPreview.classList.add('active-tab');
            }
        }

        // Event listeners for tab buttons
        tabButtonFiles.addEventListener('click', () => showTab('tab-content-files'));
        tabButtonHtmlPreview.addEventListener('click', () => showTab('tab-content-html-preview'));
        tabButtonDocuments.addEventListener('click', () => showTab('tab-content-documents'));
        tabButtonWebSearches.addEventListener('click', () => showTab('tab-content-web-searches'));
        tabButtonAudioPreview.addEventListener('click', () => showTab('tab-content-audio-preview'));

        // Event listener for binary paste textarea
        binaryPasteTextarea.addEventListener('paste', (event) => {
            const items = event.clipboardData?.items;
            if (!items) return;

            event.preventDefault(); // Prevent default paste behavior

            let filesProcessed = false;
            for (const item of items) {
                if (item.type.startsWith('image/')) {
                    const file = item.getAsFile();
                    if (file) {
                        // Create a new File object with a unique name for pasted images
                        const uniqueFileName = `pasted_image_${crypto.randomUUID()}.${file.type.split('/')[1] || 'png'}`;
                        const uniqueFile = new File([file], uniqueFileName, { type: file.type });
                        processFiles([uniqueFile]); // Pass the uniquely named File object
                        filesProcessed = true;
                    }
                } else if (item.type === 'text/plain') {
                    const pastedText = event.clipboardData.getData('text/plain');
                    // Simple check for base64 (can be more robust)
                    if (pastedText.startsWith('data:') || (pastedText.length > 500 && pastedText.match(/^[a-zA-Z0-9+/=]+$/))) {
                        try {
                            const mimeTypeMatch = pastedText.match(/^data:([a-zA-Z0-9]+\/[a-zA-Z0-9-.+]+);base64,/);
                            if (mimeTypeMatch) {
                                const mimeType = mimeTypeMatch[1];
                                const base64Data = pastedText.split(',')[1];
                                // For base64 text, create a dummy File-like object with unique name
                                const uniqueFileName = `pasted_data_${crypto.randomUUID()}.${mimeType.split('/')[1] || 'bin'}`;
                                const newFile = {
                                    name: uniqueFileName,
                                    mimeType: mimeType,
                                    data: base64Data,
                                    url: pastedText
                                };
                                // No existingFile check needed here, as name is unique
                                uploadedFiles.push(newFile);
                                fileDataArray.push(newFile);
                                renderAllUploadedLists();
                                filesProcessed = true;
                            }
                        } catch (e) {
                            console.error("Error processing pasted base64 data:", e);
                        }
                    } else {
                        // If it's plain text and not a data URL, append it to the textarea
                        const currentText = binaryPasteTextarea.value;
                        binaryPasteTextarea.value = currentText + pastedText;
                    }
                }
            }
            // If files were processed, clear the textarea to indicate readiness for new paste,
            // otherwise, leave text if it was just plain text.
            if (filesProcessed) {
                binaryPasteTextarea.value = '';
            }
        });

        // Event listener for HTML preview textarea input
        htmlPreviewTextarea.addEventListener('input', () => {
            const htmlContent = htmlPreviewTextarea.value;
            const iframeDoc = htmlPreviewIframe.contentWindow.document;
            iframeDoc.open();
            iframeDoc.write(htmlContent);
            iframeDoc.close();
        });

        // Event listener for opening HTML in a new tab
        openHtmlNewTabButton.addEventListener('click', () => {
            const htmlContent = htmlPreviewTextarea.value;
            if (htmlContent) {
                const newWindow = window.open();
                newWindow.document.write(htmlContent);
                newWindow.document.close();
            } else {
                // Instead of alert, display a message within the UI or console
                console.log('No HTML content to open.');
            }
        });

        // Event listener for opening fullscreen HTML modal
        htmlPreviewIframe.addEventListener('click', () => {
            const htmlContent = htmlPreviewTextarea.value;
            if (htmlContent) {
                fullscreenHtmlIframe.srcdoc = htmlContent;
                fullscreenHtmlModal.classList.add('active');
            }
        });

        // Event listener for closing fullscreen HTML modal
        closeFullscreenModalButton.addEventListener('click', () => {
            fullscreenHtmlModal.classList.remove('active');
            fullscreenHtmlIframe.srcdoc = ''; // Clear iframe content
        });

        // Event listener for "Reproducir Texto Personalizado" button
        playSelectedMessageButton.addEventListener('click', async () => {
            const textToPlay = customAudioTextarea.value.trim();
            const selectedVoice = previewAudioVoiceSelector.value;
            await playAudioForText(textToPlay, selectedVoice, playSelectedMessageButton);
        });

        // Event listener for "Generar Audio de Seleccionados" button
        generateSelectedMessagesAudioButton.addEventListener('click', async () => {
            const textToGenerate = customAudioTextarea.value.trim();
            const selectedVoice = previewAudioVoiceSelector.value;

            if (!textToGenerate || selectedMessagesTexts.length === 0) {
                console.log('No hay mensajes seleccionados para generar audio.');
                // Optionally, provide user feedback
                return;
            }
            await playAudioForText(textToGenerate, selectedVoice, generateSelectedMessagesAudioButton);
        });

        // Function to stop the current media stream (video or audio)
        function stopCurrentStream() {
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
                liveVideoPreview.srcObject = null;
                currentStream = null;
                livePreviewContainer.style.display = 'none';
                recordingIndicator.style.display = 'none'; // Hide indicator
                liveVideoPreview.style.display = 'block'; // Ensure video is visible by default
                audioWaveformCanvas.style.display = 'none'; // Hide canvas

                if (audioContext) {
                    audioContext.close(); // Close audio context if open
                    audioContext = null;
                }
                if (audioProcessAnimationFrameId) {
                    cancelAnimationFrame(audioProcessAnimationFrameId); // Stop audio processing loop
                    audioProcessAnimationFrameId = null;
                }
                isRecordingAudio = false; // Reset recording state
            }
        }

        // Function to start camera stream with specified facing mode
        async function startCamera(facingMode = 'user') { // 'user' for front, 'environment' for rear
            stopCurrentStream();
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: facingMode },
                    audio: false
                });
                liveVideoPreview.srcObject = stream;
                currentStream = stream;
                livePreviewContainer.style.display = 'block';
                liveVideoPreview.style.display = 'block';
                audioWaveformCanvas.style.display = 'none';
                // displaySystemMessage(`Modo Directo activado. Cámara ${facingMode === 'user' ? 'Frontal' : 'Trasera'} iniciada.`); // Message removed
            } catch (err) {
                console.error(`Error al acceder a la cámara ${facingMode === 'user' ? 'Frontal' : 'Trasera'}: `, err);
                displaySystemMessage(`Error al acceder a la cámara ${facingMode === 'user' ? 'Frontal' : 'Trasera'}. Asegúrate de que los permisos están concedidos.`);
                isLiveModeActive = false;
                liveModeButton.classList.remove('live-active');
                livePreviewContainer.style.display = 'none';
            } finally {
                liveModeChoiceModal.style.display = 'none';
                updateInputPlaceholder();
            }
        }

        // Function to start screen sharing stream
        async function startScreenShare() {
            stopCurrentStream();
            try {
                const stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: false });
                liveVideoPreview.srcObject = stream;
                currentStream = stream;
                livePreviewContainer.style.display = 'block';
                liveVideoPreview.style.display = 'block';
                audioWaveformCanvas.style.display = 'none';
                // displaySystemMessage("Modo Directo activado. Compartiendo pantalla."); // Message removed

                stream.getVideoTracks()[0].onended = () => {
                    isLiveModeActive = false;
                    liveModeButton.classList.remove('live-active');
                    stopCurrentStream();
                    // displaySystemMessage("Modo Directo desactivado. Compartir pantalla detenido."); // Message removed
                    updateInputPlaceholder();
                };
            } catch (err) {
                console.error("Error al compartir pantalla: ", err);
                // Modified error message for better user feedback
                if (err.name === "NotAllowedError" || err.message.includes("permissions policy")) {
                    displaySystemMessage("Error al compartir pantalla: El navegador denegó el acceso. Es posible que necesites conceder permisos de 'captura de pantalla' o que esta función no esté disponible en este entorno (por ejemplo, en un iframe). Intenta abrir la aplicación en una pestaña de navegador completa.");
                } else {
                    displaySystemMessage("Error al compartir pantalla: Acceso denegado o no permitido. Verifica los permisos.");
                }
                isLiveModeActive = false;
                liveModeButton.classList.remove('live-active');
                livePreviewContainer.style.display = 'none';
            } finally {
                liveModeChoiceModal.style.display = 'none';
                updateInputPlaceholder();
            }
        }

        // Function to draw the audio waveform
        function drawWaveform() {
            const canvasCtx = audioWaveformCanvas.getContext('2d');
            const WIDTH = audioWaveformCanvas.width;
            const HEIGHT = audioWaveformCanvas.height;

            audioProcessAnimationFrameId = requestAnimationFrame(drawWaveform);

            analyser.getByteTimeDomainData(dataArray);

            canvasCtx.clearRect(0, 0, WIDTH, HEIGHT); // Clear the canvas

            canvasCtx.lineWidth = 2;
            canvasCtx.strokeStyle = isRecordingAudio ? 'rgb(0, 0, 255)' : 'rgb(150, 150, 150)'; // Blue when recording, grey when listening
            canvasCtx.beginPath();

            const sliceWidth = WIDTH * 1.0 / bufferLength;
            let x = 0;

            for (let i = 0; i < bufferLength; i++) {
                const v = dataArray[i] / 128.0;
                const y = v * HEIGHT / 2;

                if (i === 0) {
                    canvasCtx.moveTo(x, y);
                } else {
                    canvasCtx.lineTo(x, y);
                }

                x += sliceWidth;
            }

            canvasCtx.lineTo(WIDTH, HEIGHT / 2);
            canvasCtx.stroke();

            // Integrate audio detection into the waveform drawing loop
            analyser.getByteFrequencyData(dataArray); // Use frequency data for volume detection

            let sum = 0;
            for (let i = 0; i < bufferLength; i++) {
                sum += dataArray[i];
            }
            const average = sum / bufferLength; // Simple average as a volume indicator

            if (average > AUDIO_THRESHOLD && !isRecordingAudio) {
                // Sound detected, start recording
                isRecordingAudio = true;
                silenceStartTime = 0; // Reset silence timer
                audioChunks = []; // Clear previous chunks
                mediaRecorder.start();
                displaySystemMessage("Grabación de audio iniciada...");
                recordingIndicator.textContent = "Grabando audio... (ACTIVO)";
            } else if (average <= AUDIO_THRESHOLD && isRecordingAudio) {
                if (silenceStartTime === 0) {
                    silenceStartTime = Date.now(); // Start silence timer
                } else if (Date.now() - silenceStartTime > SILENCE_DURATION_MS) {
                    // Silence detected for long enough, stop recording
                    isRecordingAudio = false;
                    mediaRecorder.stop();
                    recordingIndicator.textContent = "Escuchando audio... (ESPERANDO)";
                }
            } else if (average > AUDIO_THRESHOLD && isRecordingAudio) {
                // Still recording and sound is active, reset silence timer
                silenceStartTime = 0;
            }
        }

        // Function to start microphone audio stream and recording logic
        async function startMicrophone() {
            stopCurrentStream();
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                currentStream = stream;
                livePreviewContainer.style.display = 'block';
                liveVideoPreview.style.display = 'none';
                audioWaveformCanvas.style.display = 'block';
                recordingIndicator.style.display = 'block';
                recordingIndicator.textContent = "Escuchando audio... (ESPERANDO)";
                // displaySystemMessage("Modo Directo activado. Micrófono iniciado. Escuchando sonido..."); // Message removed

                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                bufferLength = analyser.fftSize;
                dataArray = new Uint8Array(bufferLength);

                const microphone = audioContext.createMediaStreamSource(stream);
                microphone.connect(analyser);

                mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
                mediaRecorder.ondataavailable = event => {
                    audioChunks.push(event.data);
                };

                mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    const reader = new FileReader();
                    reader.readAsDataURL(audioBlob);
                    reader.onloadend = () => {
                        const base64data = reader.result.split(',')[1];
                        const audioFile = {
                            name: `audio_recording_${Date.now()}.webm`,
                            mimeType: 'audio/webm',
                            data: base64data,
                            url: reader.result
                        };
                        fileDataArray.push(audioFile);
                        uploadedFiles.push(audioFile);
                        renderAllUploadedLists();

                        displaySystemMessage("Grabación de audio finalizada. Enviando al chat...");
                        const message = messageInput.value.trim();
                        sendMessage(message || "Audio grabado.", fileDataArray);
                        messageInput.value = '';
                        fileDataArray = [];
                    };
                    recordingIndicator.textContent = "Escuchando audio... (ESPERANDO)";
                };

                drawWaveform();

            } catch (err) {
                console.error("Error al acceder al micrófono: ", err);
                displaySystemMessage("Error al acceder al micrófono. Asegúrate de que los permisos están concedidos.");
                isLiveModeActive = false;
                liveModeButton.classList.remove('live-active');
                livePreviewContainer.style.display = 'none';
                recordingIndicator.style.display = 'none';
                audioWaveformCanvas.style.display = 'none';
            } finally {
                liveModeChoiceModal.style.display = 'none';
                updateInputPlaceholder();
            }
        }

        // Function to toggle live camera/screen/microphone preview and the live chat bar
        function toggleLivePreview() {
            if (isLiveModeActive) {
                liveModeChoiceModal.style.display = 'flex';
                liveChatBar.classList.add('active'); // Show live chat bar
            } else {
                stopCurrentStream();
                // displaySystemMessage("Modo Directo desactivado."); // Message removed
                liveModeChoiceModal.style.display = 'none';
                liveChatBar.classList.remove('active'); // Hide live chat bar
            }
            updateInputPlaceholder();
        }

        // Event listener for Report button
        reportButton.addEventListener('click', () => {
            isReportModeActive = !isReportModeActive;
            reportButton.classList.toggle('report-active', isReportModeActive);

            if (isHtmlModeActive) {
                isHtmlModeActive = false;
                htmlModeButton.classList.remove('html-active');
            }
            if (isLiveModeActive) {
                isLiveModeActive = false;
                liveModeButton.classList.remove('live-active');
                toggleLivePreview();
            }

            if (isReportModeActive) {
                console.log("Modo Informe activado.");
                displaySystemMessage("Modo Informe activado.");
            } else {
                console.log("Modo Informe desactivado.");
                displaySystemMessage("Modo Informe desactivado.");
            }
            updateInputPlaceholder();
        });

        // Event listener for HTML Mode button (now for HTML filtering)
        htmlModeButton.addEventListener('click', () => {
            isHtmlModeActive = !isHtmlModeActive;
            htmlModeButton.classList.toggle('html-active', isHtmlModeActive);

            if (isReportModeActive) {
                isReportModeActive = false;
                reportButton.classList.remove('report-active');
            }
            if (isLiveModeActive) {
                isLiveModeActive = false;
                liveModeButton.classList.remove('live-active');
                toggleLivePreview();
            }

            if (isHtmlModeActive) {
                console.log("Modo HTML activado.");
                displaySystemMessage("Modo HTML activado.");
            } else {
                console.log("Modo HTML desactivado.");
            }
            updateInputPlaceholder();
        });

        // Event listener for Live Mode button
        liveModeButton.addEventListener('click', () => {
            isLiveModeActive = !isLiveModeActive;
            liveModeButton.classList.toggle('live-active', isLiveModeActive);

            if (isReportModeActive) {
                isReportModeActive = false;
                reportButton.classList.remove('report-active');
            }
            if (isHtmlModeActive) {
                isHtmlModeActive = false;
                htmlModeButton.classList.remove('html-active');
            }

            toggleLivePreview();
            updateInputPlaceholder();
        });

        // Event listeners for Live Mode Choice Modal buttons
        chooseFrontCameraButton.addEventListener('click', () => startCamera('user')); // Pass 'user' for front camera
        chooseRearCameraButton.addEventListener('click', () => startCamera('environment')); // Pass 'environment' for rear camera
        chooseScreenButton.addEventListener('click', startScreenShare);
        chooseMicrophoneButton.addEventListener('click', startMicrophone);
        closeLiveChoiceModalButton.addEventListener('click', () => {
            liveModeChoiceModal.style.display = 'none';
            if (isLiveModeActive) {
                // If live mode is still active but modal closed without selection, deactivate it
                isLiveModeActive = false;
                liveModeButton.classList.remove('live-active');
                stopCurrentStream(); // Ensure stream is stopped if nothing was chosen
                liveChatBar.classList.remove('active'); // Hide live chat bar
                updateInputPlaceholder();
            }
        });

        // Event listener for sending messages from the new live chat bar
        sendLiveMessageButton.addEventListener('click', () => {
            const liveMessage = liveMessageInput.value.trim();
            if (liveMessage) {
                // Here, you can define what happens with the live message.
                // For example, log it to the console, send it to a different API endpoint, etc.
                console.log("Mensaje de Directo enviado (no en el chat principal):", liveMessage);
                displaySystemMessage(`Mensaje en Directo: "${liveMessage}" (no mostrado en el chat principal)`); // Show a system message in the main chat
                liveMessageInput.value = ''; // Clear the input field
            }
        });

        // Event listener for Enter key in live message input
        liveMessageInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                sendLiveMessageButton.click();
                event.preventDefault(); // Prevent new line in input
            }
        });


        // Initial rendering of math on page load and setting font size
        document.addEventListener("DOMContentLoaded", function () {
            renderMath();
            chatContainer.style.fontSize = fontSizeSelector.value + 'px';
            populateConversationMessagesList();
            updateInputPlaceholder();
        });
    </script>
</body>
</html>
